From 0365de81a27da24a226e9b07b9899c4843db1bba Mon Sep 17 00:00:00 2001
From: Eilo <eilo2518@gmail.com>
Date: Fri, 4 May 2012 00:32:29 -0500
Subject: [PATCH 22/87] 2.9.5 RubySanctum: Halion nueva script

---
 .../reanemu/2012_04_26_100_world_ruby_sanctum.sql  |  298 +++
 src/server/game/Scripting/ScriptLoader.cpp         |    2 +
 src/server/game/Spells/SpellMgr.cpp                |   12 +
 src/server/scripts/Northrend/CMakeLists.txt        |    1 +
 .../ChamberOfAspects/RubySanctum/boss_halion.cpp   | 1995 ++++++++++++++++++++
 .../RubySanctum/instance_ruby_sanctum.cpp          |  129 +-
 .../ChamberOfAspects/RubySanctum/ruby_sanctum.h    |   41 +-
 7 files changed, 2421 insertions(+), 57 deletions(-)
 create mode 100644 sql/updates/world/reanemu/2012_04_26_100_world_ruby_sanctum.sql
 create mode 100644 src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/boss_halion.cpp

diff --git a/sql/updates/world/reanemu/2012_04_26_100_world_ruby_sanctum.sql b/sql/updates/world/reanemu/2012_04_26_100_world_ruby_sanctum.sql
new file mode 100644
index 0000000..ba6c797
--- /dev/null
+++ b/sql/updates/world/reanemu/2012_04_26_100_world_ruby_sanctum.sql
@@ -0,0 +1,298 @@
+-- !! TODO LIST
+-- !! * Fix all damage from all NPCs.
+
+-- Combustion / Consumption scaling aura
+DELETE FROM `spell_dbc` WHERE `id`=70507;
+INSERT INTO `spell_dbc` (`Id`,`Attributes`,`AttributesEx`,`AttributesEx2`,`CastingTimeIndex`,`ProcChance`,`DurationIndex`,`RangeIndex`,`StackAmount`,`Effect1`,`EffectBasePoints1`,`EffectImplicitTargetA1`,`EffectApplyAuraName1`,`DmgMultiplier1`,`Comment`) VALUES
+(70507,0x00000100,0x00000400,0x0,1,101,21,1,99,6,10,1,61,1, 'Halion - Combustion & Consumption Scale Aura');
+
+-- Copy damage spell
+-- Attr1 0x8|0x80|0x400|0x10000
+-- Attr2 0x20000000
+-- Attr3 0x40000|0x20000000
+-- Attr5 0x8|0x20000|0x40000
+-- Attr6 0x2000|0x1000000|0x20000000
+DELETE FROM `spell_dbc` WHERE `id`=74810;
+INSERT INTO `spell_dbc` (`Id`,`Attributes`,`AttributesEx`,`AttributesEx2`,`AttributesEx3`,`AttributesEx4`,`AttributesEx5`,`AttributesEx6`,`AttributesEx7`,`CastingTimeIndex`,`Effect1`,`EffectImplicitTargetA1`,`MaxAffectedTargets`,`Comment`) VALUES
+(74810,0,0x00010488,0x20000000,0x2004000,0,0x00060008,0x21002000,0,1,3,25,1, 'Halion - Copy Damage');
+
+-- Bosses respawn time
+UPDATE `creature` SET `spawntimesecs`=604800 WHERE `id` IN (39751,39746,39747);
+
+-- Trash mobs respawn time
+UPDATE `creature` SET `spawntimesecs`=1209600 WHERE `map`=724 AND `id` NOT IN (39751,39746,39747);
+
+-- Difficulty entries
+UPDATE `creature_template` SET `difficulty_entry_1`=40143,`difficulty_entry_2`=40144,`difficulty_entry_3`=40145 WHERE `entry`=40142;
+UPDATE `creature_template` SET `difficulty_entry_1`=40470,`difficulty_entry_2`=40471,`difficulty_entry_3`=40472 WHERE `entry`=40081;
+
+-- ---------------------------------------------------------------- --
+-- ----------------------- Template updates ----------------------- --
+-- ---------------------------------------------------------------- --
+
+UPDATE `creature_template` SET `flags_extra`=130,`ScriptName`= 'npc_halion_controller', `faction_A`=35,`faction_H`=35,`exp`=2 WHERE `entry`=40146; -- 40146 - Halion Controller
+
+-- Halion
+UPDATE `creature_template` SET `mindmg`=509,`maxdmg`=683,`attackpower`=805,`dmg_multiplier`=35,`faction_A`=14,`faction_H`=14, `exp`=2 WHERE `entry` IN (39863,39864,39944,39945,40142);
+UPDATE `creature_template` SET `ScriptName`= 'boss_halion',`flags_extra`=`flags_extra`|0x1 WHERE `entry`=39863;
+
+-- Trash mobs
+UPDATE `creature_template` SET `mindmg`=422,`maxdmg`=586,`attackpower`=642,`dmg_multiplier`=7.5 WHERE `entry` IN (40417,40418,40419,40420,40421,40422,40423,40424);
+
+-- Pre bosses
+UPDATE `creature_template` SET `mindmg`=509,`maxdmg`=683,`attackpower`=805,`dmg_multiplier`=35 WHERE `entry` IN (39751,39920,39747,39823,39746,39805);
+
+UPDATE `creature_template` SET `flags_extra`=130 WHERE `entry` IN (40041, 40042, 40043, 40044); -- 40041, 40042, 40043 & 40044 - Meteor Strike
+UPDATE `creature_template` SET `flags_extra`=130 WHERE `entry`=40029; -- 40029 - Meteor Strike (Initial)
+UPDATE `creature_template` SET `flags_extra`=130 WHERE `entry`=40055; -- 40055 - Meteor Strike
+
+UPDATE `creature_template` SET `faction_A`=14,`faction_H`=14,`exp`=2,`mindmg`=509,`maxdmg`=683,`attackpower`=805,`dmg_multiplier`=35 WHERE `entry`=40142; -- 40142 - Halion     - The Twilight Destroyer
+UPDATE `creature_template` SET `faction_A`=14,`faction_H`=14,`exp`=2,`mindmg`=509,`maxdmg`=683,`attackpower`=805,`dmg_multiplier`=35 WHERE `entry`=40143; -- 40143 - Halion (1) - The Twilight Destroyer
+UPDATE `creature_template` SET `faction_A`=14,`faction_H`=14,`exp`=2,`mindmg`=509,`maxdmg`=683,`attackpower`=805,`dmg_multiplier`=35 WHERE `entry`=40144; -- 40144 - Halion (2) - The Twilight Destroyer
+UPDATE `creature_template` SET `faction_A`=14,`faction_H`=14,`exp`=2,`mindmg`=509,`maxdmg`=683,`attackpower`=805,`dmg_multiplier`=35 WHERE `entry`=40145; -- 40145 - Halion (3) - The Twilight Destroyer
+
+-- 40091 - Orb Rotation Focus
+UPDATE `creature_template` SET `modelid1`=11686,`modelid2`=169,`scale`=1,`unit_flags`=33554688 WHERE `entry`=40091;
+
+UPDATE `creature_template` SET `InhabitType`=7,`modelid1`=11686,`modelid2`=169,`VehicleId`=718,`unit_flags`=33554688 WHERE `entry`=40081; -- 40081 - Orb Carrier 
+UPDATE `creature_template` SET `InhabitType`=7,`modelid1`=11686,`modelid2`=169,`VehicleId`=718,`unit_flags`=33554688 WHERE `entry`=40470; -- 40470 - Orb Carrier (1)
+UPDATE `creature_template` SET `InhabitType`=7,`modelid1`=11686,`modelid2`=169,`VehicleId`=746,`unit_flags`=33554688 WHERE `entry`=40471; -- 40471 - Orb Carrier (2)
+UPDATE `creature_template` SET `InhabitType`=7,`modelid1`=11686,`modelid2`=169,`VehicleId`=746,`unit_flags`=33554688 WHERE `entry`=40472; -- 40472 - Orb Carrier (3)
+UPDATE `creature_template` SET `scale`=1,`flags_extra`=130,`exp`=2,`baseattacktime`=2000,`unit_flags`=33554432 WHERE `entry` IN(40001, 40135); -- 40001 & 40135 - Combustion & Consumption
+
+-- 40469, 40468, 40083 & 40100 - Shadow Orb
+UPDATE `creature_template` SET `InhabitType`=7,`flags_extra`=2,`unit_flags`=33554432,`baseattacktime`=2000,`speed_walk`=2.4,`speed_run`=0.85714,`faction_A`=14,`faction_H`=14,`exp`=2,`maxlevel`=80,`minlevel`=80, unit_flags = unit_flags | 4 | 512, `type`=4, `HoverHeight`=0, `ScriptName`= '' WHERE `entry` IN (40469, 40468, 40083, 40100);
+
+-- Script Names
+UPDATE `creature_template` SET `ScriptName`= 'boss_twilight_halion' WHERE `entry`=40142; -- Twilight Halion
+UPDATE `creature_template` SET `ScriptName`= 'npc_orb_carrier' WHERE `entry`=40081;
+UPDATE `creature_template` SET `ScriptName`= 'npc_combustion_consumption' WHERE `entry` IN(40001, 40135);
+UPDATE `creature_template` SET `ScriptName`= 'npc_meteor_strike_initial' WHERE `entry`=40029;
+UPDATE `creature_template` SET `ScriptName`= 'npc_meteor_strike' WHERE `entry` IN (40041, 40042, 40043, 40044);
+
+-- Model info update
+UPDATE `creature_model_info` SET `bounding_radius`=3.8,`combat_reach`=7.6,`gender`=2 WHERE `modelid`=16946;
+
+-- Spell 75074 cannot be found in any DBC file and is not found in sniffs.
+-- thus leaving us with no other choice than editing a WDB field (kids, do not try this at home)
+UPDATE `gameobject_template` SET `data10`=74807,`WDBVerified`=-12340 WHERE `entry` IN (202794, 202795);
+UPDATE `gameobject_template` SET `flags`=`flags`|32 WHERE `entry`=202794;
+UPDATE `gameobject_template` SET `faction`=35, `flags`=`flags`|32,`ScriptName`='go_exit_twilight_realm',`WDBVerified`=-12340 WHERE `entry`=202796;
+
+-- Spell scripts
+DELETE FROM `spell_script_names` WHERE `ScriptName`= 'spell_halion_meteor_strike_marker';
+DELETE FROM `spell_script_names` WHERE `ScriptName`= 'spell_halion_fiery_combustion';
+DELETE FROM `spell_script_names` WHERE `ScriptName`= 'spell_halion_soul_consumption';
+DELETE FROM `spell_script_names` WHERE `ScriptName`= 'spell_halion_mark_of_combustion';
+DELETE FROM `spell_script_names` WHERE `ScriptName`= 'spell_halion_mark_of_consumption';
+DELETE FROM `spell_script_names` WHERE `ScriptName`= 'spell_halion_combustion_consumption_summon';
+DELETE FROM `spell_script_names` WHERE `ScriptName`= 'spell_halion_leave_twilight_realm';
+DELETE FROM `spell_script_names` WHERE `ScriptName`= 'spell_halion_enter_twilight_realm';
+DELETE FROM `spell_script_names` WHERE `ScriptName`= 'spell_halion_twilight_phasing';
+DELETE FROM `spell_script_names` WHERE `ScriptName`= 'spell_halion_twilight_cutter';
+DELETE FROM `spell_script_names` WHERE `ScriptName`= 'spell_halion_clear_debuffs';
+DELETE FROM `spell_script_names` WHERE `ScriptName`= 'spell_halion_track_rotation';
+INSERT INTO `spell_script_names` (`spell_id`,`ScriptName`) VALUES
+(74641, 'spell_halion_meteor_strike_marker'),
+(74562, 'spell_halion_fiery_combustion'),
+(74792, 'spell_halion_soul_consumption'),
+(74567, 'spell_halion_mark_of_combustion'),
+(74795, 'spell_halion_mark_of_consumption'),
+(74610, 'spell_halion_combustion_consumption_summon'),
+(74800, 'spell_halion_combustion_consumption_summon'),
+(74812, 'spell_halion_leave_twilight_realm'),
+(74807, 'spell_halion_enter_twilight_realm'),
+(74808, 'spell_halion_twilight_phasing'),
+(74769, 'spell_halion_twilight_cutter'),
+(77844, 'spell_halion_twilight_cutter'),
+(77845, 'spell_halion_twilight_cutter'),
+(75396, 'spell_halion_clear_debuffs'),
+(77846, 'spell_halion_twilight_cutter'),
+(74758, 'spell_halion_track_rotation');
+
+-- Texts
+DELETE FROM `creature` WHERE `id`=40146;
+DELETE FROM `creature_text` WHERE `entry`=39863;
+DELETE FROM `creature_text` WHERE `entry`=40142;
+DELETE FROM `creature_text` WHERE `entry`=40146;
+DELETE FROM `creature_text` WHERE `entry`=40083;
+INSERT INTO `creature_text` (`entry`,`groupid`,`id`,`text`,`type`,`language`,`probability`,`emote`,`duration`,`sound`,`comment`) VALUES 
+(39863,0,0, 'Meddlesome insects! You are too late. The Ruby Sanctum is lost!',14,0,100,1,0,17499, 'Halion'),
+(39863,1,0, 'Your world teeters on the brink of annihilation. You will ALL bear witness to the coming of a new age of DESTRUCTION!',14,0,100,0,0,17500, 'Halion'),
+(39863,2,0, 'The heavens burn!',14,0,100,0,0,17505, 'Halion'),
+(39863,3,0, 'You will find only suffering within the realm of twilight! Enter if you dare!',14,0,100,0,0,17507, 'Halion'),
+(39863,4,0, 'Relish this victory, mortals, for it will be your last! This world will burn with the master''s return!',14,0,100,0,0,17503, 'Halion'),
+(39863,5,0, 'Another "hero" falls.',14,0,100,0,0,17501, 'Halion'),
+(39863,6,0, 'Not good enough.',14,0,100,0,0,17504, 'Halion'),
+
+(40142,0,0, 'Beware the shadow!',14,0,100,0,0,17506, 'Halion'),
+(40142,1,0, 'I am the light and the darkness! Cower, mortals, before the herald of Deathwing!',14,0,100,0,0,17508, 'Halion'),
+
+(40146,0,0, 'Your companion''s efforts have forced Halion further out of the Physical realm!',42,0,100,0,0,0, 'Halion Controller'),
+(40146,1,0, 'Your efforts have forced Halion further into the Physical realm!',42,0,100,0,0,0, 'Halion Controller'),
+(40146,2,0, 'Your companion''s efforts have forced Halion further out of the Twilight realm!',42,0,100,0,0,0, 'Halion Controller'),
+(40146,3,0, 'Your efforts have forced Halion further into the Twilight realm!',42,0,100,0,0,0, 'Halion Controller'),
+(40146,4,0, 'Without pressure in both realms, Halion begins to regenerate.',42,0,100,0,0,0, 'Halion Controller'),
+
+(40083,0,0, 'The orbiting spheres pulse with dark energy!',41,0,100,0,0,0, 'Shadow Orb');
+
+-- Spawns
+SET @OGUID = 240110; -- Set guid (1 required)
+DELETE FROM `gameobject` WHERE `id`=203624;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(@OGUID,203624,724,15,0x20,3157.372,533.9948,72.8887,1.034892,0,0,0.4946623,0.8690853,120,0,0); -- GO_TWILIGHT_FLAME_RING
+
+SET @GUID = 240111; -- Set guid (3 required)
+DELETE FROM `creature` WHERE `id` IN (40081,40091,40151);
+INSERT INTO `creature` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`modelid`,`equipment_id`,`position_x`,`position_y`,`position_z`,`orientation`,`spawntimesecs`,`spawndist`,`currentwaypoint`,`curhealth`,`curmana`,`MovementType`,`npcflag`,`unit_flags`,`dynamicflags`) VALUES
+(@GUID,40091,724,15,0x20,0,0,3113.711,533.5382,72.96869,1.936719,300,0,0,1,0,0,0,0,0), -- Orb Rotation Focus
+(@GUID+1,40081,724,15,0x20,0,0,3153.75,533.1875,72.97205,0,300,0,0,1,0,0,0,0,0), -- Orb Carrier
+(@GUID+2,40151,724,15,0x21,0,0,3153.75,533.1875,72.97205,0,300,0,0,1,0,0,0,0,0); -- Combat Stalker
+
+-- Pathing for Orb Rotation Focus Entry: 40091
+SET @PATH = @GUID * 10;
+UPDATE `creature` SET `spawndist`=0,`MovementType`=2 WHERE `guid`=@GUID;
+DELETE FROM `creature_addon` WHERE `guid`=@GUID;
+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@GUID,@PATH,1,0, '');
+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`orientation`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
+(@PATH,1,3117.59,547.7952,72.96869,0,0,0,0,100,0),
+(@PATH,2,3127.461,558.7396,72.96869,0,0,0,0,100,0),
+(@PATH,3,3138.042,567.9514,72.98305,0,0,0,0,100,0),
+(@PATH,4,3154.09,574.9636,72.98305,0,0,0,0,100,0),
+(@PATH,5,3172.565,567.493,72.86058,0,0,0,0,100,0),
+(@PATH,6,3181.981,555.8889,72.9127,0,0,0,0,100,0),
+(@PATH,7,3189.923,533.3542,73.0377,0,0,0,0,100,0),
+(@PATH,8,3182.315,513.4202,72.9771,0,0,0,0,100,0),
+(@PATH,9,3177.168,504.3802,72.7271,0,0,0,0,100,0),
+(@PATH,10,3167.878,496.8368,72.50312,0,0,0,0,100,0),
+(@PATH,11,3152.238,490.4705,72.62009,0,0,0,0,100,0),
+(@PATH,12,3138.174,499.3056,72.87009,0,0,0,0,100,0),
+(@PATH,13,3126.83,506.0799,72.95515,0,0,0,0,100,0),
+(@PATH,14,3120.68,515.3524,72.95515,0,0,0,0,100,0),
+(@PATH,15,3113.711,533.5382,72.96869,0,0,0,0,100,0);
+
+-- Vehicle accessory for Orb Carrier
+DELETE FROM `vehicle_template_accessory` WHERE `entry` IN (40081,40470,40471,40472);
+INSERT INTO `vehicle_template_accessory` (`entry`,`accessory_entry`,`seat_id`,`minion`,`description`,`summontype`,`summontimer`) VALUES
+(40081,40083,0,1, 'Orb Carrier',6,30000),
+(40081,40100,1,1, 'Orb Carrier',6,30000),
+
+(40470,40083,0,1, 'Orb Carrier',6,30000),
+(40470,40100,1,1, 'Orb Carrier',6,30000),
+
+(40471,40083,0,1, 'Orb Carrier',6,30000),
+(40471,40100,1,1, 'Orb Carrier',6,30000),
+(40471,40468,2,1, 'Orb Carrier (seat guessed)',6,30000),
+(40471,40469,3,1, 'Orb Carrier (seat guessed)',6,30000),
+
+(40472,40083,0,1, 'Orb Carrier',6,30000),
+(40472,40100,1,1, 'Orb Carrier',6,30000),
+(40472,40468,2,1, 'Orb Carrier (seat guessed)',6,30000),
+(40472,40469,3,1, 'Orb Carrier (seat guessed)',6,30000);
+
+-- Vehicle spellclicks
+DELETE FROM `npc_spellclick_spells` WHERE `npc_entry` IN (40081,40470,40471,40472);
+INSERT INTO `npc_spellclick_spells` (`npc_entry`,`spell_id`,`cast_flags`,`user_type`) VALUES
+(40081,46598,0,1), -- Ride Vehicle Hardcoded
+(40470,46598,0,1),
+(40471,46598,0,1),
+(40472,46598,0,1);
+
+-- Conditions
+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=13 AND `SourceEntry`=74758;
+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=13 AND `SourceEntry`=75886;
+INSERT INTO `conditions` (`SourceTypeOrReferenceId`, `SourceGroup`, `SourceEntry`, `SourceId`, `ElseGroup`, `ConditionTypeOrReference`, `ConditionTarget`, `ConditionValue1`, `ConditionValue2`, `ConditionValue3`, `NegativeCondition`, `ErrorTextId`, `ScriptName`, `Comment`) VALUES
+(13,1,75886,0,0,31,0,3,40683,0,0,0, "", "Blazing Aura can only target Living Embers"),
+(13,1,75886,0,1,31,0,3,40684,0,0,0, "", "Blazing Aura can only target Living Embers"),
+(13,1,74758,0,0,31,0,3,40091,0,0,0, "", "Track Rotation can only target Orb Rotation Focus");
+
+-- Not applicable for now (until merge), just found this randomly while re-parsing sniffs
+-- UPDATE creature_template SET HoverHeight=1.6 WHERE entry=40421;
+
+
+-- ------------------ Guessed Data (only to make it as close as blizzlike) ------------------ --
+
+-- Halion and Twilight Halion
+-- Damage modifier
+UPDATE `creature_template` SET `dmg_multiplier`=95, `baseattacktime`=1500 WHERE `entry` IN (39863,40142);
+UPDATE `creature_template` SET `dmg_multiplier`=145, `baseattacktime`=1500 WHERE `entry` IN (39864,40143);
+UPDATE `creature_template` SET `dmg_multiplier`=145, `baseattacktime`=1500 WHERE `entry` IN (39944,40144);
+UPDATE `creature_template` SET `dmg_multiplier`=215, `baseattacktime`=1500 WHERE `entry` IN (39945,40145);
+
+-- Other Stat
+UPDATE `creature_template` SET `speed_walk`=1.6, `speed_run`= 1.42857, `unit_flags` = 32832 WHERE `entry` IN (39864,39944,39945);
+UPDATE `creature_template` SET `minlevel`= 83, `maxlevel`=83, `speed_walk`=1.6, `speed_run`= 1.42857, `unit_flags` = 559168 WHERE `entry` IN (40143,40144,40145);
+
+-- Immunity
+UPDATE `creature_template` SET `mechanic_immune_mask` = `mechanic_immune_mask` | 
+1|          -- charm
+2|          -- disorient
+4|          -- disarm
+8|          -- distract
+16|         -- fear
+32|         -- grip
+64|         -- root
+256|        -- silence
+512|        -- sleep
+1024|       -- snare
+2048|       -- stun
+4096|       -- freeze
+8192|       -- knockout
+65536|      -- polymorph
+131072|     -- banish
+524288|     -- shackle
+1048576|    -- mount
+4194304|    -- turn
+8388608|    -- horror
+33554432|   -- interrupt
+67108864|   -- daze
+536870912   -- sapped
+where `entry` IN (39863,40142,39864,40143,39944,40144,39945,40145);
+
+-- Mini Boss
+-- Baltharus the Warborn
+UPDATE `creature_template` SET `dmg_multiplier`=75 WHERE `entry`=39751;
+UPDATE `creature_template` SET `dmg_multiplier`=110, `lootid`=39947, `speed_walk`=2.8, `scale`=1.5 WHERE `entry`=39920;
+-- Clone
+UPDATE `creature_template` SET `mindmg`=509, `maxdmg`=683, `attackpower`=805, `dmg_multiplier`=75 WHERE `entry`=39899;
+UPDATE `creature_template` SET `mindmg`=509, `maxdmg`=683, `attackpower`=805, `dmg_multiplier`=110, `baseattacktime`=2000, `unit_flags`=64, `flags_extra`=1 WHERE `entry`=39922;
+
+-- Saviana Ragefire
+UPDATE `creature_template` SET `dmg_multiplier`=75 WHERE `entry`=39747;
+UPDATE `creature_template` SET `dmg_multiplier`=110, `exp`=2, `speed_walk`=2, `speed_run`=2.14286, `scale`=1.2, `lootid`=39948, `flags_extra`=1 WHERE `entry`=39823;
+
+-- General Zarithrian
+UPDATE `creature_template` SET `dmg_multiplier`=75 WHERE `entry`=39746;
+UPDATE `creature_template` SET `dmg_multiplier`=110, `lootid`=39946, `exp`=2, `flags_extra`=1 WHERE `entry`=39805;
+
+-- Immunity
+UPDATE `creature_template` SET `mechanic_immune_mask` = `mechanic_immune_mask` | 
+1|          -- charm
+2|          -- disorient
+4|          -- disarm
+8|          -- distract
+16|         -- fear
+32|         -- grip
+64|         -- root
+256|        -- silence
+512|        -- sleep
+1024|       -- snare
+2048|       -- stun
+4096|       -- freeze
+8192|       -- knockout
+65536|      -- polymorph
+131072|     -- banish
+524288|     -- shackle
+1048576|    -- mount
+4194304|    -- turn
+8388608|    -- horror
+33554432|   -- interrupt
+67108864|   -- daze
+536870912   -- sapped
+where `entry` IN (
+39751, 39920,   -- Baltharus the Warborn
+39899, 39922,   -- Baltharus the Warborn Clone
+39747, 39823,   -- Saviana Ragefire
+39746, 39805    -- General Zarithrian
+);
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index e5ebb66..02ac544 100755
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -485,6 +485,7 @@ void AddSC_instance_icecrown_citadel();
 void AddSC_icecrown_citadel();
 void AddSC_instance_ruby_sanctum();      // Ruby Sanctum
 void AddSC_ruby_sanctum();
+void AddSC_boss_halion();
 void AddSC_boss_baltharus_the_warborn();
 void AddSC_boss_saviana_ragefire();
 void AddSC_boss_general_zarithrian();
@@ -1191,6 +1192,7 @@ void AddNorthrendScripts()
     AddSC_icecrown_citadel();
     AddSC_instance_ruby_sanctum();      // Ruby Sanctum
     AddSC_ruby_sanctum();
+    AddSC_boss_halion();
     AddSC_boss_baltharus_the_warborn();
     AddSC_boss_saviana_ragefire();
     AddSC_boss_general_zarithrian();
diff --git a/src/server/game/Spells/SpellMgr.cpp b/src/server/game/Spells/SpellMgr.cpp
index 06e4978..a0d2cf1 100755
--- a/src/server/game/Spells/SpellMgr.cpp
+++ b/src/server/game/Spells/SpellMgr.cpp
@@ -3523,6 +3523,18 @@ void SpellMgr::LoadDbcDataCorrections()
             case 72405: // Broken Frostmourne
                 spellInfo->EffectRadiusIndex[1] = EFFECT_RADIUS_200_YARDS;   // 200yd
                 break;
+            //
+            // Ruby Sanctum Spells
+            //
+            case 74809: // Summon Twilight Portal
+                spellInfo->EffectImplicitTargetA[0] = TARGET_DEST_DEST;
+                break;
+            case 74769: // Twilight Cutter
+            case 77844: // Twilight Cutter
+            case 77845: // Twilight Cutter
+            case 77846: // Twilight Cutter
+                spellInfo->EffectRadiusIndex[0] = EFFECT_RADIUS_100_YARDS;
+                break;
             case 40055: // Introspection
             case 40165: // Introspection
             case 40166: // Introspection
diff --git a/src/server/scripts/Northrend/CMakeLists.txt b/src/server/scripts/Northrend/CMakeLists.txt
index ab659cd..1fe6f16 100644
--- a/src/server/scripts/Northrend/CMakeLists.txt
+++ b/src/server/scripts/Northrend/CMakeLists.txt
@@ -48,6 +48,7 @@ set(scripts_STAT_SRCS
   Northrend/ChamberOfAspects/RubySanctum/instance_ruby_sanctum.cpp
   Northrend/ChamberOfAspects/RubySanctum/ruby_sanctum.h
   Northrend/ChamberOfAspects/RubySanctum/ruby_sanctum.cpp
+  Northrend/ChamberOfAspects/RubySanctum/boss_halion.cpp
   Northrend/ChamberOfAspects/RubySanctum/boss_baltharus_the_warborn.cpp
   Northrend/ChamberOfAspects/RubySanctum/boss_saviana_ragefire.cpp
   Northrend/ChamberOfAspects/RubySanctum/boss_general_zarithrian.cpp
diff --git a/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/boss_halion.cpp b/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/boss_halion.cpp
new file mode 100644
index 0000000..f72e80f
--- /dev/null
+++ b/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/boss_halion.cpp
@@ -0,0 +1,1995 @@
+﻿/*
+ * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "ScriptPCH.h"
+#include "SpellScript.h"
+#include "SpellAuraEffects.h"
+#include "Spell.h"
+#include "Vehicle.h"
+#include "MapManager.h"
+#include "ruby_sanctum.h"
+
+/*
+TODO:
+- Look over how threat should be treaten (apparently there's a creature (entry 40151) that keeps 200 threat on both Halion's)
+- See if corporeality code can be improved
+- Script adds and surrounding trash
+*/
+
+/*
+Info list
+- Twilight Halion seems to be spawned while Halion is spawned.
+*/
+
+enum Texts
+{
+    SAY_INTRO                        = 0, // Meddlesome insects! You are too late. The Ruby Sanctum is lost!
+    SAY_AGGRO                        = 1, // Your world teeters on the brink of annihilation. You will ALL bear witness to the coming of a new age of DESTRUCTION!
+    SAY_METEOR_STRIKE                = 2, // The heavens burn!
+    SAY_PHASE_TWO                    = 3, // You will find only suffering within the realm of twilight! Enter if you dare!
+    SAY_DEATH                        = 4, // Relish this victory, mortals, for it will be your last! This world will burn with the master's return!
+    SAY_KILL                         = 5, // Another "hero" falls.
+    SAY_BERSERK                      = 6, // Not good enough.
+
+    SAY_SPHERE_PULSE                 = 0, // Beware the shadow!
+    SAY_PHASE_THREE                  = 1, // I am the light and the darkness! Cower, mortals, before the herald of Deathwing!
+
+    EMOTE_TWILIGHT_OUT_TWILIGHT      = 0, // Your companion's efforts have forced Halion further out of the Twilight realm!
+    EMOTE_TWILIGHT_IN_TWILIGHT       = 1, // Your efforts have forced Halion further into the Twilight realm!
+    EMOTE_PHYSICAL_OUT_PHYSICAL      = 2, // Your companion's efforts have forced Halion further out of the Physical realm!
+    EMOTE_PHYSICAL_IN_PHYSICAL       = 3, // Your efforts have forced Halion further into the Physical realm!
+    EMOTE_REGENERATE                 = 4, // Without pressure in both realms, Halion begins to regenerate.
+
+    EMOTE_WARN_LASER                 = 0, // The orbiting spheres pulse with dark energy!
+};
+
+enum Spells
+{
+    // Halion
+    SPELL_FLAME_BREATH                  = 74525,
+    SPELL_CLEAVE                        = 74524,
+    SPELL_METEOR_STRIKE                 = 74637,
+    SPELL_TAIL_LASH                     = 74531,
+    SPELL_TWILIGHT_PRECISION            = 78243,
+
+    SPELL_FIERY_COMBUSTION              = 74562,
+    SPELL_MARK_OF_COMBUSTION            = 74567,
+    SPELL_FIERY_COMBUSTION_EXPLOSION    = 74607,
+    SPELL_FIERY_COMBUSTION_SUMMON       = 74610,
+
+    // Combustion & Consumption
+    SPELL_SCALE_AURA                    = 70507, // Aura created in spell_dbc.
+    SPELL_COMBUSTION_DAMAGE_AURA        = 74629,
+    SPELL_CONSUMPTION_DAMAGE_AURA       = 74803,
+
+    // Twilight Halion
+    SPELL_DARK_BREATH                   = 74806,
+
+    SPELL_MARK_OF_CONSUMPTION           = 74795,
+    SPELL_SOUL_CONSUMPTION              = 74792,
+    SPELL_SOUL_CONSUMPTION_EXPLOSION    = 74799,
+    SPELL_SOUL_CONSUMPTION_SUMMON       = 74800,
+    SPELL_DUSK_SHROUD                   = 75476,
+
+    // Living Inferno
+    SPELL_BLAZING_AURA                  = 75885,
+
+    // Halion Controller
+    SPELL_COSMETIC_FIRE_PILLAR          = 76006,
+    SPELL_FIERY_EXPLOSION               = 76010,
+    SPELL_CLEAR_DEBUFFS                 = 75396,
+
+    // Meteor Strike
+    SPELL_METEOR_STRIKE_COUNTDOWN       = 74641,
+    SPELL_METEOR_STRIKE_AOE_DAMAGE      = 74648,
+    SPELL_METEOR_STRIKE_FIRE_AURA_1     = 74713,
+    SPELL_METEOR_STRIKE_FIRE_AURA_2     = 74718,
+    SPELL_BIRTH_NO_VISUAL               = 40031,
+
+    // Shadow Orb
+    SPELL_TWILIGHT_CUTTER               = 74768, // Unknown dummy effect (EFFECT_0)
+    SPELL_TWILIGHT_CUTTER_TRIGGERED     = 74769,
+    SPELL_TWILIGHT_PULSE_PERIODIC       = 78861,
+    SPELL_TRACK_ROTATION                = 74758,
+
+    // Misc
+    SPELL_TWILIGHT_DIVISION             = 75063, // Phase spell from phase 2 to phase 3
+    SPELL_LEAVE_TWILIGHT_REALM          = 74812,
+    SPELL_TWILIGHT_PHASING              = 74808, // Phase spell from phase 1 to phase 2
+    SPELL_SUMMON_TWILIGHT_PORTAL        = 74809, // Summons go 202794
+    SPELL_TWILIGHT_MENDING              = 75509,
+    SPELL_TWILIGHT_REALM                = 74807,
+
+    SPELL_COPY_DAMAGE                   = 74810, // Not in DBCs but found in sniffs. Not cast.
+};
+
+enum Events
+{
+    // Halion
+    EVENT_ACTIVATE_FIREWALL     = 1,
+    EVENT_CLEAVE                = 2, // Used by Twilight Halion too
+    EVENT_FLAME_BREATH          = 3,
+    EVENT_METEOR_STRIKE         = 4,
+    EVENT_FIERY_COMBUSTION      = 5,
+    EVENT_TAIL_LASH             = 6,
+
+    // Halion Controller
+    EVENT_START_INTRO           = 7,
+    EVENT_INTRO_PROGRESS_1      = 8,
+    EVENT_INTRO_PROGRESS_2      = 9,
+    EVENT_INTRO_PROGRESS_3      = 10,
+    EVENT_CHECK_CORPOREALITY    = 11,
+    EVENT_SHADOW_PULSARS_SHOOT  = 12,
+    EVENT_BERSERK               = 13,
+
+    // Meteor Strike
+    EVENT_SPAWN_METEOR_FLAME    = 14,
+
+    // Twilight Halion
+    EVENT_DARK_BREATH           = 15,
+    EVENT_SOUL_CONSUMPTION      = 16,
+
+    // Living Ember
+    EVENT_EMBER_ENRAGE          = 17,
+
+    // Misc
+    EVENT_CHECK_THREAT          = 18,
+    // This is all shitty for now. Halion, Twilight Halion, and Halion Controller will check their threat list
+    // every two seconds and if they find out that either one of the NPCs lost aggro on any player, that would
+    // mean that the encounter has to reset. Not yet implemented, this comment block is rather some way for me
+    // to brain a bit about this fubarish stuff.
+
+    EVENT_TWILIGHT_MENDING      = 19,
+    EVENT_PHASE_THREE           = 20,
+    EVENT_TRACK_ROTATION        = 21,
+};
+
+enum Actions
+{
+    // Meteor Strike
+    ACTION_METEOR_STRIKE_BURN   = 1,
+    ACTION_METEOR_STRIKE_AOE    = 2,
+
+    // Halion
+    ACTION_BERSERK              = 3,
+
+    // Halion Controller
+    ACTION_PHASE_TWO            = 4,
+    ACTION_PHASE_THREE          = 5,
+    ACTION_CLEANUP              = 6,
+
+    // Orb Carrier
+    ACTION_SHOOT                = 7,
+    ACTION_ROTATE               = 8,
+    ACTION_STOP_ROTATE          = 9,
+};
+
+enum Phases
+{
+    PHASE_ALL           = 0,
+    PHASE_ONE           = 1,
+    PHASE_TWO           = 2,
+    PHASE_THREE         = 3,
+
+    PHASE_ONE_MASK      = 1 << PHASE_ONE,
+    PHASE_TWO_MASK      = 1 << PHASE_TWO,
+    PHASE_THREE_MASK    = 1 << PHASE_THREE,
+};
+
+enum Misc
+{
+    DATA_TWILIGHT_DAMAGE_TAKEN   = 1,
+    DATA_MATERIAL_DAMAGE_TAKEN   = 2,
+    DATA_STACKS_DISPELLED        = 3,
+    DATA_FIGHT_PHASE             = 4,
+    DATA_MENDING                 = 5,
+    RING_RADIUS                  = 45,
+};
+
+enum OrbCarrierSeats
+{
+    SEAT_NORTH            = 0,
+    SEAT_SOUTH            = 1,
+    SEAT_EAST             = 2,
+    SEAT_WEST             = 3,
+};
+
+Position const HalionSpawnPos = {3156.67f, 533.8108f, 72.98822f, 3.159046f};
+
+struct CorporealityData
+{
+    uint8 materialPercentage;
+    uint32 materialRealmSpell;
+    uint32 twilightRealmSpell;
+};
+
+uint8 const MAX_CORPOREALITY_STATE = 11;
+
+CorporealityData const corporealityReference[MAX_CORPOREALITY_STATE] =
+{
+    {  0, 74836, 74831},
+    { 10, 74835, 74830},
+    { 20, 74834, 74829},
+    { 30, 74833, 74828},
+    { 40, 74832, 74827},
+    { 50, 74826, 74826},
+    { 60, 74827, 74832},
+    { 70, 74828, 74833},
+    { 80, 74829, 74834},
+    { 90, 74830, 74835},
+    {100, 74831, 74836},
+};
+
+class boss_halion : public CreatureScript
+{
+    public:
+        boss_halion() : CreatureScript("boss_halion") { }
+
+        struct boss_halionAI : public BossAI
+        {
+            boss_halionAI(Creature* creature) : BossAI(creature, DATA_HALION) { }
+
+            void Reset()
+            {
+                instance->SendEncounterUnit(ENCOUNTER_FRAME_DISENGAGE, me);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                _Reset();
+            }
+
+            void EnterCombat(Unit* who)
+            {
+                _EnterCombat();
+                Talk(SAY_AGGRO);
+                instance->SendEncounterUnit(ENCOUNTER_FRAME_ENGAGE, me, 1);
+                me->AddAura(SPELL_TWILIGHT_PRECISION,me);
+
+                events.Reset();
+                events.SetPhase(PHASE_ONE);
+                // Schedule events without taking care of phases, since EventMap will not be updated under phase 2.
+                events.ScheduleEvent(EVENT_ACTIVATE_FIREWALL, 10000);
+                events.ScheduleEvent(EVENT_CLEAVE, urand(8000, 10000));
+                events.ScheduleEvent(EVENT_FLAME_BREATH, urand(10000, 12000));
+                events.ScheduleEvent(EVENT_METEOR_STRIKE, urand(20000, 25000));
+                events.ScheduleEvent(EVENT_FIERY_COMBUSTION, urand(15000, 18000));
+                events.ScheduleEvent(EVENT_TAIL_LASH, 10000);
+
+                // Due to Halion's EventMap not being updated under phase two, Berserk will be triggered by the Controller
+                // so that the timer still ticks in phase two.
+                if (Creature* controller = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_HALION_CONTROLLER)))
+                    controller->AI()->EnterCombat(who);
+            }
+
+            void JustDied(Unit* /*killer*/)
+            {
+                _JustDied();
+                Talk(SAY_DEATH);
+                instance->SendEncounterUnit(ENCOUNTER_FRAME_DISENGAGE, me);
+
+                if (Creature* controller = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_HALION_CONTROLLER)))
+                    controller->AI()->Reset();
+
+                // This block shouldn't be needed anymore after spell 74810 is working.
+                if (Creature* twilightHalion = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_TWILIGHT_HALION)))
+                    if (twilightHalion->isAlive())
+                        twilightHalion->Kill(twilightHalion);
+            }
+
+            void KilledUnit(Unit* victim)
+            {
+                if (victim->GetTypeId() == TYPEID_PLAYER)
+                    Talk(SAY_KILL);
+            }
+
+            void JustReachedHome()
+            {
+                instance->SendEncounterUnit(ENCOUNTER_FRAME_DISENGAGE, me);
+
+                me->RemoveAurasDueToSpell(SPELL_TWILIGHT_PHASING);
+
+                if (GameObject* go = me->FindNearestGameObject(GO_HALION_PORTAL_1,200.0f))
+                    go->RemoveFromWorld();
+                if (Creature* controller = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_HALION_CONTROLLER)))
+                    controller->AI()->Reset();
+
+                _JustReachedHome();
+            }
+
+            Position const* GetMeteorStrikePosition() const { return &_meteorStrikePos; }
+
+            void DamageTaken(Unit* attacker, uint32& damage)
+            {
+                if ((me->GetHealth() - damage) > 0 && (events.GetPhaseMask() & (PHASE_ONE_MASK | PHASE_THREE_MASK)) && attacker->GetEntry() != NPC_TWILIGHT_HALION)
+                {
+                    if (Creature* twilightHalion = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_TWILIGHT_HALION)))
+                    {
+                        SpellNonMeleeDamage damageInfo(me, twilightHalion, SPELL_COPY_DAMAGE, SPELL_SCHOOL_MASK_NONE);
+                        damageInfo.damage = damage;
+                        me->SendSpellNonMeleeDamageLog(&damageInfo);
+                        me->DealSpellDamage(&damageInfo, false);
+                    }
+                }
+
+                // Check phase under 40% health, hackish way to prevent exploit
+                if (HealthBelowPct(40) && !(events.GetPhaseMask() & PHASE_THREE_MASK))
+                {
+                    events.SetPhase(PHASE_THREE);
+                    if (Creature* controller = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_HALION_CONTROLLER)))
+                        controller->AI()->DoAction(ACTION_PHASE_THREE);
+                }
+
+                if (me->HealthBelowPctDamaged(75, damage) && (events.GetPhaseMask() & PHASE_ONE_MASK))
+                {
+                    events.SetPhase(PHASE_TWO);
+                    events.DelayEvents(2600); // 2.5 sec + 0.1 sec lag
+
+                    me->CastStop();
+                    me->AttackStop();
+
+                    Talk(SAY_PHASE_TWO);
+                    DoCast(me, SPELL_TWILIGHT_PHASING);
+                }
+
+                if ((events.GetPhaseMask() & PHASE_THREE_MASK) && attacker->GetEntry() != NPC_TWILIGHT_HALION)
+                    if (Creature* controller = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_HALION_CONTROLLER)))
+                        controller->AI()->SetData(DATA_MATERIAL_DAMAGE_TAKEN, damage);
+            }
+
+            bool CanAIAttack(Unit const* victim) { return !victim->HasAura(SPELL_TWILIGHT_REALM); }
+
+            void UpdateAI(uint32 const diff)
+            {
+                if (!(events.GetPhaseMask() & PHASE_TWO_MASK))
+                    if (!UpdateVictim())
+                        return;
+
+                if (me->HasUnitState(UNIT_STATE_CASTING))
+                    return;
+
+                // Events won't be updated under phase two.
+                if (!(events.GetPhaseMask() & PHASE_TWO_MASK))
+                    events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_ACTIVATE_FIREWALL:
+                        {
+                            // Firewall is activated 10 seconds after starting encounter, DOOR_TYPE_ROOM is only instant.
+                            if (GameObject* firewall = ObjectAccessor::GetGameObject(*me, instance->GetData64(DATA_FLAME_RING)))
+                                instance->HandleGameObject(instance->GetData64(DATA_FLAME_RING), false, firewall);
+                            if (GameObject* firewall = ObjectAccessor::GetGameObject(*me, instance->GetData64(DATA_TWILIGHT_FLAME_RING)))
+                                instance->HandleGameObject(instance->GetData64(DATA_TWILIGHT_FLAME_RING), false, firewall);
+                            break;
+                        }
+                        case EVENT_FLAME_BREATH:
+                            DoCast(me, SPELL_FLAME_BREATH);
+                            events.ScheduleEvent(EVENT_FLAME_BREATH, 25000);
+                            break;
+                        case EVENT_CLEAVE:
+                            DoCastVictim(SPELL_CLEAVE);
+                            events.ScheduleEvent(EVENT_CLEAVE, urand(8000, 10000));
+                            break;
+                        case EVENT_TAIL_LASH:
+                            DoCastAOE(SPELL_TAIL_LASH);
+                            events.ScheduleEvent(EVENT_TAIL_LASH, 10000);
+                            break;
+                        case EVENT_METEOR_STRIKE:
+                        {
+                            if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 0.0f, true, -SPELL_TWILIGHT_REALM))
+                            {
+                                target->GetPosition(&_meteorStrikePos);
+                                me->CastSpell(_meteorStrikePos.GetPositionX(), _meteorStrikePos.GetPositionY(), _meteorStrikePos.GetPositionZ(), SPELL_METEOR_STRIKE, true, NULL, NULL, me->GetGUID());
+                                Talk(SAY_METEOR_STRIKE);
+                            }
+                            events.ScheduleEvent(EVENT_METEOR_STRIKE, 40000);
+                            break;
+                        }
+                        case EVENT_FIERY_COMBUSTION:
+                        {
+                            Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 0.0f, true, -SPELL_TWILIGHT_REALM);
+                            if (!target)
+                                target = SelectTarget(SELECT_TARGET_RANDOM, 0, 0.0f, true, -SPELL_TWILIGHT_REALM);
+                            if (target)
+                                DoCast(target, SPELL_FIERY_COMBUSTION);
+                            events.ScheduleEvent(EVENT_FIERY_COMBUSTION, 25000);
+                            break;
+                        }
+                        case EVENT_TWILIGHT_MENDING:
+                            DoCast(me, SPELL_TWILIGHT_MENDING, true);
+                            events.ScheduleEvent(EVENT_TWILIGHT_MENDING, 2000);
+                            break;
+                        default:
+                            break;
+                    }
+                }
+
+                DoMeleeAttackIfReady();
+            }
+
+            void SetData(uint32 index, uint32 value)
+            {
+                if (index == DATA_FIGHT_PHASE)
+                    events.SetPhase(value);
+                else if (index == DATA_MENDING)
+                {
+                    if (value)
+                        events.ScheduleEvent(EVENT_TWILIGHT_MENDING, 1000);
+                    else
+                        events.CancelEvent(EVENT_TWILIGHT_MENDING);
+                }
+            }
+
+            uint32 GetData(uint32 index)
+            {
+                if (index == DATA_FIGHT_PHASE)
+                    return events.GetPhaseMask();
+
+                return 0;
+            }
+
+            void DoAction(int32 const action)
+            {
+                if (action != ACTION_BERSERK)
+                    return;
+
+                Talk(SAY_BERSERK);
+                DoCast(me, SPELL_BERSERK);
+            }
+
+        private:
+            Position _meteorStrikePos;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return GetRubySanctumAI<boss_halionAI>(creature);
+        }
+};
+
+typedef boss_halion::boss_halionAI HalionAI;
+
+class boss_twilight_halion : public CreatureScript
+{
+    public:
+        boss_twilight_halion() : CreatureScript("boss_twilight_halion") { }
+
+        struct boss_twilight_halionAI : public ScriptedAI
+        {
+            boss_twilight_halionAI(Creature* creature) : ScriptedAI(creature),
+                _instance(creature->GetInstanceScript())
+            {
+                me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_KNOCK_BACK, true);
+                me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_KNOCK_BACK_DEST, true);
+                me->SetPhaseMask(0x20, true); // Should not be visible with phasemask 0x21, so only 0x20
+                events.SetPhase(PHASE_ONE);
+            }
+
+            void Reset()
+            {
+                if (Creature* halion = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_HALION)))
+                    halion->AI()->Reset();
+                if(GameObject* go = ObjectAccessor::GetGameObject(*me,_portal1))
+                    go->RemoveFromWorld();
+                if(GameObject* go = ObjectAccessor::GetGameObject(*me,_portal2))
+                    go->RemoveFromWorld();
+                if (Creature* orbCarrier = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_ORB_CARRIER)))
+                    orbCarrier->AI()->DoAction(ACTION_STOP_ROTATE);
+            }
+
+            void EnterCombat(Unit* who)
+            {
+                if (Creature* whoCreature = who->ToCreature())
+                    if (whoCreature->GetEntry() == NPC_COMBAT_STALKER)
+                        return;
+
+                _instance->SendEncounterUnit(ENCOUNTER_FRAME_ENGAGE, me, 2);
+                me->AddAura(SPELL_TWILIGHT_PRECISION,me);
+                me->AddAura(SPELL_DUSK_SHROUD,me);
+                events.Reset();
+                events.SetPhase(PHASE_TWO);
+                if (Creature* halion = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_HALION)))
+                    me->SetHealth(halion->GetHealth());
+                if (Creature* controller = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_HALION_CONTROLLER)))
+                    controller->AI()->DoAction(ACTION_PHASE_TWO);
+                //! All of Twilight Halion's abilities are not phase dependant as he is never on Phase One.
+                //! However, phasemasks are "needed" so that we know on which phase we are when Halion takes
+                //! damage, causing corporeality not to tick in phase two.
+                events.ScheduleEvent(EVENT_DARK_BREATH, urand(10000, 15000));
+                events.ScheduleEvent(EVENT_SOUL_CONSUMPTION, 20000);
+                events.ScheduleEvent(EVENT_CLEAVE, urand(8000, 10000));
+                events.ScheduleEvent(EVENT_TAIL_LASH, 10000);
+                if (Creature* orbCarrier = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_ORB_CARRIER)))
+                    orbCarrier->AI()->DoAction(ACTION_ROTATE);
+            }
+
+            void KilledUnit(Unit* victim)
+            {
+                if (victim->GetTypeId() == TYPEID_PLAYER)
+                    Talk(SAY_KILL);
+
+                // Victims should not be in the Twilight Realm
+                me->CastSpell(victim, SPELL_LEAVE_TWILIGHT_REALM, true);
+            }
+
+            void JustDied(Unit* killer)
+            {
+                if (Creature* halion = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_HALION)))
+                {
+                    // Ensure looting
+                    if (me->IsDamageEnoughForLootingAndReward())
+                        halion->LowerPlayerDamageReq(halion->GetMaxHealth());
+
+                    if (halion->isAlive())
+                        killer->Kill(halion);
+                }
+
+                if (Creature* controller = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_HALION_CONTROLLER)))
+                    controller->CastSpell(controller, SPELL_CLEAR_DEBUFFS);
+                if (Creature* orbCarrier = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_ORB_CARRIER)))
+                    orbCarrier->AI()->DoAction(ACTION_STOP_ROTATE);
+                _instance->SendEncounterUnit(ENCOUNTER_FRAME_DISENGAGE, me);
+            }
+
+            void JustReachedHome()
+            {
+                _instance->SendEncounterUnit(ENCOUNTER_FRAME_DISENGAGE, me);
+                if (Creature* controller = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_HALION_CONTROLLER)))
+                    controller->CastSpell(controller, SPELL_CLEAR_DEBUFFS);
+                ScriptedAI::JustReachedHome();
+                if (Creature* halion = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_HALION)))
+                    halion->AI()->Reset();
+            }
+
+            void DamageTaken(Unit* attacker, uint32& damage)
+            {
+                if (me->GetHealth() - damage > 0 && !(events.GetPhaseMask() & PHASE_ONE_MASK) && attacker->GetEntry() != NPC_HALION)
+                {
+                    if (Creature* halion = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_HALION)))
+                    {
+                        SpellNonMeleeDamage damageInfo(me, halion, SPELL_COPY_DAMAGE, SPELL_SCHOOL_MASK_NONE);
+                        damageInfo.damage = damage;
+                        me->SendSpellNonMeleeDamageLog(&damageInfo);
+                        me->DealSpellDamage(&damageInfo, false);
+                    }
+                }
+
+                if (me->HealthBelowPctDamaged(50, damage) && (events.GetPhaseMask() & PHASE_TWO_MASK))
+                {
+                    events.SetPhase(PHASE_THREE);
+                    events.DelayEvents(2600); // 2.5 sec + 0.1sec lag
+
+                    me->CastStop();
+                    DoCast(me, SPELL_TWILIGHT_DIVISION);
+                    Talk(SAY_PHASE_THREE);
+                    //! Stop here, else damage that triggered the phase change will be taken
+                    //! into consideration in the next lines.
+                    return;
+                }
+
+                if ((events.GetPhaseMask() & PHASE_THREE_MASK) && attacker->GetEntry() != NPC_HALION)
+                    if (Creature* controller = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_HALION_CONTROLLER)))
+                        controller->AI()->SetData(DATA_TWILIGHT_DAMAGE_TAKEN, damage);
+            }
+
+            void SpellHitTarget(Unit* /*who*/, SpellInfo const* spell)
+            {
+                if (spell->Id != SPELL_TWILIGHT_DIVISION)
+                    return;
+
+                DoCast(me, corporealityReference[5].twilightRealmSpell);
+                if (Creature* halion = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_HALION)))
+                {
+                    halion->CastSpell(halion, corporealityReference[5].materialRealmSpell, false);
+                    halion->RemoveAurasDueToSpell(SPELL_TWILIGHT_PHASING);
+                    halion->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                    if (GameObject* go = halion->FindNearestGameObject(GO_HALION_PORTAL_1,200.0f))
+                        go->RemoveFromWorld();
+                    if (GameObject* go = halion->SummonGameObject(GO_HALION_PORTAL_EXIT,HalionSpawnPos.GetPositionX()+40,HalionSpawnPos.GetPositionY(),HalionSpawnPos.GetPositionZ(),0.0f,0.0f,0.0f,0.0f,0.0f,0))
+                    {
+                        go->SetPhaseMask(0x20,true);
+                        _portal1 = go->GetGUID();
+                    }
+                    if (GameObject* go = halion->SummonGameObject(GO_HALION_PORTAL_EXIT,HalionSpawnPos.GetPositionX()-40,HalionSpawnPos.GetPositionY(),HalionSpawnPos.GetPositionZ(),0.0f,0.0f,0.0f,0.0f,0.0f,0))
+                    {
+                        go->SetPhaseMask(0x20,true);
+                        _portal2 = go->GetGUID();
+                    }
+                }
+                events.ScheduleEvent(EVENT_PHASE_THREE, 10000);
+                if (Creature* controller = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_HALION_CONTROLLER)))
+                    controller->AI()->DoAction(ACTION_PHASE_THREE);
+            }
+
+            bool CanAIAttack(Unit const* victim)
+            {
+                return victim->HasAura(SPELL_TWILIGHT_REALM);
+            }
+
+            void DoAction(int32 const action)
+            {
+                if (action == ACTION_BERSERK)
+                    DoCast(me, SPELL_BERSERK);
+            }
+
+            void SetData(uint32 index, uint32 value)
+            {
+                if (index == DATA_MENDING)
+                {
+                    if (value)
+                        events.ScheduleEvent(EVENT_TWILIGHT_MENDING, 1000);
+                    else
+                        events.CancelEvent(EVENT_TWILIGHT_MENDING);
+                }
+            }
+
+            void UpdateAI(uint32 const diff)
+            {
+                if (!UpdateVictim() || me->HasUnitState(UNIT_STATE_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_DARK_BREATH:
+                        {
+                            DoCast(me, SPELL_DARK_BREATH);
+                            events.ScheduleEvent(EVENT_DARK_BREATH, urand(10000, 15000));
+                            break;
+                        }
+                        case EVENT_SOUL_CONSUMPTION:
+                        {
+                            Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 0.0f, true, SPELL_TWILIGHT_REALM);
+                            if (!target)
+                                target = SelectTarget(SELECT_TARGET_RANDOM, 0, 0.0f, true, SPELL_TWILIGHT_REALM);
+                            if (target)
+                                DoCast(target, SPELL_SOUL_CONSUMPTION);
+                            events.ScheduleEvent(EVENT_SOUL_CONSUMPTION, 20000);
+                            break;
+                        }
+                        case EVENT_CLEAVE:
+                            DoCastVictim(SPELL_CLEAVE);
+                            events.ScheduleEvent(EVENT_CLEAVE, urand(8000, 10000));
+                            break;
+                        case EVENT_TAIL_LASH:
+                            DoCastAOE(SPELL_TAIL_LASH);
+                            events.ScheduleEvent(EVENT_TAIL_LASH, 10000);
+                            break;
+                        case EVENT_PHASE_THREE:
+                            if (Creature* halion = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_HALION)))
+                                halion->AI()->SetData(DATA_FIGHT_PHASE, PHASE_THREE);
+                            break;
+                        case EVENT_TWILIGHT_MENDING:
+                            DoCast(me, SPELL_TWILIGHT_MENDING, true);
+                            events.ScheduleEvent(EVENT_TWILIGHT_MENDING, 2000);
+                            break;
+                        default:
+                            break;
+                    }
+                }
+
+                DoMeleeAttackIfReady();
+            }
+
+        private:
+            InstanceScript* _instance;
+            EventMap events;
+            uint64 _portal1;
+            uint64 _portal2;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return GetRubySanctumAI<boss_twilight_halionAI>(creature);
+        }
+};
+
+typedef boss_twilight_halion::boss_twilight_halionAI twilightHalionAI;
+
+class npc_halion_controller : public CreatureScript
+{
+    public:
+        npc_halion_controller() : CreatureScript("npc_halion_controller") { }
+
+        struct npc_halion_controllerAI : public ScriptedAI
+        {
+            npc_halion_controllerAI(Creature* creature) : ScriptedAI(creature),
+                _instance(creature->GetInstanceScript()), _summons(me)
+            {
+                me->SetPhaseMask(me->GetPhaseMask() | 0x20, true);
+            }
+
+            void Reset()
+            {
+                me->SetReactState(REACT_PASSIVE);
+                _summons.DespawnAll();
+                _events.Reset();
+                DoCast(me, SPELL_CLEAR_DEBUFFS);
+            }
+
+            void JustSummoned(Creature* who)
+            {
+                _summons.Summon(who);
+            }
+
+            void EnterCombat(Unit* who)
+            {
+                if (Creature* combatStalker = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_COMBAT_STALKER)))
+                    combatStalker->AI()->EnterCombat(who);
+
+                _events.ScheduleEvent(EVENT_BERSERK, 8 * MINUTE * IN_MILLISECONDS);
+            }
+
+            void DoAction(int32 const action)
+            {
+                switch (action)
+                {
+                    case ACTION_INTRO_HALION:
+                    {
+                        _events.Reset();
+                        _events.ScheduleEvent(EVENT_START_INTRO, 2000);
+                        _events.ScheduleEvent(EVENT_INTRO_PROGRESS_1, 6000);
+                        _events.ScheduleEvent(EVENT_INTRO_PROGRESS_2, 10000);
+                        _events.ScheduleEvent(EVENT_INTRO_PROGRESS_3, 14000);
+                        break;
+                    }
+                    case ACTION_PHASE_TWO:
+                    {
+                        _events.ScheduleEvent(EVENT_SHADOW_PULSARS_SHOOT, 10000); // Fix the timer
+                        break;
+                    }
+                    case ACTION_PHASE_THREE:
+                    {
+                        _events.ScheduleEvent(EVENT_CHECK_CORPOREALITY, 20000);
+                        TwilightDamageTaken = 0;
+                        MaterialDamageTaken = 0;
+                        materialCorporealityValue = 50;
+                        _instance->DoUpdateWorldState(WORLDSTATE_CORPOREALITY_TOGGLE, 1);
+                        _instance->DoUpdateWorldState(WORLDSTATE_CORPOREALITY_MATERIAL, 50);
+                        _instance->DoUpdateWorldState(WORLDSTATE_CORPOREALITY_TWILIGHT, 50);
+                        break;
+                    }
+                }
+            }
+
+            void UpdateAI(uint32 const diff)
+            {
+                _events.Update(diff);
+
+                while (uint32 eventId = _events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_START_INTRO:
+                            DoCast(me, SPELL_COSMETIC_FIRE_PILLAR, true);
+                            break;
+                        case EVENT_INTRO_PROGRESS_1:
+                            for (uint8 i = DATA_BURNING_TREE_3; i <= DATA_BURNING_TREE_4; ++i)
+                                if (GameObject* tree = ObjectAccessor::GetGameObject(*me, _instance->GetData64(i)))
+                                    _instance->HandleGameObject(_instance->GetData64(i), true, tree);
+                            break;
+                        case EVENT_INTRO_PROGRESS_2:
+                            for (uint8 i = DATA_BURNING_TREE_1; i <= DATA_BURNING_TREE_2; ++i)
+                                if (GameObject* tree = ObjectAccessor::GetGameObject(*me, _instance->GetData64(i)))
+                                    _instance->HandleGameObject(_instance->GetData64(i), true, tree);
+                            break;
+                        case EVENT_INTRO_PROGRESS_3:
+                            DoCast(me, SPELL_FIERY_EXPLOSION);
+                            if (Creature* halion = me->GetMap()->SummonCreature(NPC_HALION, HalionSpawnPos))
+                                halion->AI()->Talk(SAY_INTRO);
+                            me->GetMap()->SummonCreature(NPC_TWILIGHT_HALION, HalionSpawnPos);
+                            break;
+                        case EVENT_SHADOW_PULSARS_SHOOT:
+                        {
+                            if (Creature* twilightHalion = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_TWILIGHT_HALION)))
+                                twilightHalion->AI()->Talk(SAY_SPHERE_PULSE);
+
+                            if (Creature* orbCarrier = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_ORB_CARRIER)))
+                                orbCarrier->AI()->DoAction(ACTION_SHOOT);
+
+                            _events.ScheduleEvent(EVENT_SHADOW_PULSARS_SHOOT, 29000);   // 9 sec channel duration, every 20th second
+                            break;
+                        }
+                        case EVENT_CHECK_CORPOREALITY:
+                        {
+                            bool canUpdate = false;
+                            if (MaterialDamageTaken != 0 && TwilightDamageTaken != 0)
+                            {
+                                // Guessed scaling
+                                if (MaterialDamageTaken >= 1.02f * TwilightDamageTaken)
+                                {
+                                    TwilightDamageTaken = 0;
+                                    MaterialDamageTaken = 0;
+                                    canUpdate = (materialCorporealityValue != 0);
+                                    if (canUpdate)
+                                        materialCorporealityValue -= 10;
+                                }
+                                else if (TwilightDamageTaken >= 1.02f * MaterialDamageTaken)
+                                {
+                                    TwilightDamageTaken = 0;
+                                    MaterialDamageTaken = 0;
+                                    canUpdate = (materialCorporealityValue != 100);
+                                    if (canUpdate)
+                                        materialCorporealityValue += 10;
+                                }
+                                if (Creature* halion = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_HALION)))
+                                {
+                                    if (Creature* twilightHalion = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_TWILIGHT_HALION)))
+                                    {
+                                        halion->AI()->SetData(DATA_MENDING,0);
+                                        twilightHalion->AI()->SetData(DATA_MENDING,0);
+                                    }
+                                }
+                            }
+                            else
+                            {
+                                if (Creature* halion = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_HALION)))
+                                {
+                                    if (Creature* twilightHalion = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_TWILIGHT_HALION)))
+                                    {
+                                        halion->AI()->SetData(DATA_MENDING,1);
+                                        twilightHalion->AI()->SetData(DATA_MENDING,1);
+
+                                        Map::PlayerList const &PlList = me->GetMap()->GetPlayers();
+                                        for (Map::PlayerList::const_iterator i = PlList.begin(); i != PlList.end(); ++i)
+                                            if (Player* player = i->getSource())
+                                                Talk(EMOTE_REGENERATE, player->GetGUID());
+                                    }
+                                }
+                                _events.ScheduleEvent(EVENT_CHECK_CORPOREALITY, 15000);
+                                break;
+                            }
+
+                            if (canUpdate)
+                            {
+                                for (uint8 i = 0; i < MAX_CORPOREALITY_STATE; i++)
+                                {
+                                    if (corporealityReference[i].materialPercentage == materialCorporealityValue)
+                                    {
+                                        for (uint8 j = DATA_HALION; j <= DATA_TWILIGHT_HALION; j++)
+                                        {
+                                            if (Creature* halion = ObjectAccessor::GetCreature(*me, _instance->GetData64(j)))
+                                            {
+                                                RemoveCorporeality(halion);
+                                                halion->CastSpell(halion, (j == DATA_HALION ? corporealityReference[i].materialRealmSpell : corporealityReference[i].twilightRealmSpell), true);
+                                            }
+                                        }
+                                        break; // No need to iterate more
+                                    }
+                                }
+
+                                _instance->DoUpdateWorldState(WORLDSTATE_CORPOREALITY_MATERIAL, materialCorporealityValue);
+                                _instance->DoUpdateWorldState(WORLDSTATE_CORPOREALITY_TWILIGHT, (100 - materialCorporealityValue));
+
+                                Map::PlayerList const &playersList = me->GetMap()->GetPlayers();
+                                for (Map::PlayerList::const_iterator i = playersList.begin(); i != playersList.end(); ++i)
+                                {
+                                    if (Player* player = i->getSource())
+                                    {
+                                        if (materialCorporealityValue > 50) // Range is 0 ... 100
+                                        {
+                                            if (player->HasAura(SPELL_TWILIGHT_REALM))
+                                                Talk(EMOTE_TWILIGHT_OUT_TWILIGHT, player->GetGUID());
+                                            else
+                                                Talk(EMOTE_PHYSICAL_IN_PHYSICAL, player->GetGUID());
+                                        }
+                                        else
+                                        {
+                                            if (player->HasAura(SPELL_TWILIGHT_REALM))
+                                                Talk(EMOTE_TWILIGHT_IN_TWILIGHT, player->GetGUID());
+                                            else
+                                                Talk(EMOTE_PHYSICAL_OUT_PHYSICAL, player->GetGUID());
+                                        }
+                                    }
+                                }
+                            }
+                            _events.ScheduleEvent(EVENT_CHECK_CORPOREALITY, 15000);
+                            break;
+                        }
+                        case EVENT_BERSERK:
+                        {
+                            for (uint8 i = DATA_HALION; i <= DATA_TWILIGHT_HALION; i++)
+                                if (Creature* halion = ObjectAccessor::GetCreature(*me, _instance->GetData64(i)))
+                                    halion->AI()->DoAction(ACTION_BERSERK);
+                            break;
+                        }
+                        default:
+                            break;
+                    }
+                }
+            }
+
+            void SetData(uint32 id, uint32 value)
+            {
+                switch (id)
+                {
+                    case DATA_MATERIAL_DAMAGE_TAKEN:
+                        MaterialDamageTaken += value;
+                        break;
+                    case DATA_TWILIGHT_DAMAGE_TAKEN:
+                        TwilightDamageTaken += value;
+                        break;
+                }
+            }
+
+        private:
+
+            void RemoveCorporeality(Creature* who)
+            {
+                for (uint8 i = 0; i < MAX_CORPOREALITY_STATE; i++)
+                {
+                    if (who->HasAura(corporealityReference[i].materialRealmSpell))
+                    {
+                        who->RemoveAurasDueToSpell(corporealityReference[i].materialRealmSpell);
+                        break;
+                    }
+                    if (who->HasAura(corporealityReference[i].twilightRealmSpell))
+                    {
+                        who->RemoveAurasDueToSpell(corporealityReference[i].twilightRealmSpell);
+                        break;
+                    }
+                }
+            }
+
+            EventMap _events;
+            InstanceScript* _instance;
+            SummonList _summons;
+            uint32 TwilightDamageTaken;
+            uint32 MaterialDamageTaken;
+            uint8 materialCorporealityValue;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return GetRubySanctumAI<npc_halion_controllerAI>(creature);
+        }
+};
+
+typedef npc_halion_controller::npc_halion_controllerAI controllerAI;
+
+class npc_meteor_strike_initial : public CreatureScript
+{
+    public:
+        npc_meteor_strike_initial() : CreatureScript("npc_meteor_strike_initial") { }
+
+        struct npc_meteor_strike_initialAI : public Scripted_NoMovementAI
+        {
+            npc_meteor_strike_initialAI(Creature* creature) : Scripted_NoMovementAI(creature),
+                _instance(creature->GetInstanceScript())
+            { }
+
+            void DoAction(int32 const action)
+            {
+                switch (action)
+                {
+                    case ACTION_METEOR_STRIKE_AOE:
+                        DoCast(me, SPELL_METEOR_STRIKE_AOE_DAMAGE, true);
+                        DoCast(me, SPELL_METEOR_STRIKE_FIRE_AURA_1, true);
+                        for (std::list<Creature*>::iterator itr = _meteorList.begin(); itr != _meteorList.end(); ++itr)
+                            (*itr)->AI()->DoAction(ACTION_METEOR_STRIKE_BURN);
+                        break;
+                }
+            }
+
+            void IsSummonedBy(Unit* summoner)
+            {
+                Creature* owner = summoner->ToCreature();
+                if (!owner)
+                    return;
+
+                // Let Halion Controller count as summoner
+                if (Creature* controller = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_HALION_CONTROLLER)))
+                    controller->AI()->JustSummoned(me);
+
+                DoCast(me, SPELL_METEOR_STRIKE_COUNTDOWN);
+                DoCast(me, SPELL_BIRTH_NO_VISUAL); // Unknown purpose
+
+                if (HalionAI* halionAI = CAST_AI(HalionAI, owner->AI()))
+                {
+                    Position const* ownerPos = halionAI->GetMeteorStrikePosition();
+                    Position newPos;
+                    float angle[4];
+                    angle[0] = me->GetAngle(ownerPos);
+                    angle[1] = me->GetAngle(ownerPos) - static_cast<float>(M_PI/2);
+                    angle[2] = me->GetAngle(ownerPos) - static_cast<float>(-M_PI/2);
+                    angle[3] = me->GetAngle(ownerPos) - static_cast<float>(M_PI);
+
+                    _meteorList.clear();
+                    for (uint8 i = 0; i < 4; i++)
+                    {
+                        MapManager::NormalizeOrientation(angle[i]);
+                        me->SetOrientation(angle[i]);
+                        me->GetNearPosition(newPos, 10.0f, 0.0f); // Exact distance
+                        if (Creature* meteor = me->SummonCreature(NPC_METEOR_STRIKE_NORTH + i, newPos, TEMPSUMMON_TIMED_DESPAWN, 30000))
+                            _meteorList.push_back(meteor);
+                    }
+                }
+            }
+
+            void UpdateAI(uint32 const /*diff*/) { }
+            void EnterEvadeMode() { }
+
+        private:
+            InstanceScript* _instance;
+            std::list<Creature*> _meteorList;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return GetRubySanctumAI<npc_meteor_strike_initialAI>(creature);
+        }
+};
+
+class npc_meteor_strike : public CreatureScript
+{
+    public:
+        npc_meteor_strike() : CreatureScript("npc_meteor_strike") { }
+
+        struct npc_meteor_strikeAI : public Scripted_NoMovementAI
+        {
+            npc_meteor_strikeAI(Creature* creature) : Scripted_NoMovementAI(creature),
+                _instance(creature->GetInstanceScript())
+            {
+                _range = 5.0f;
+                _spawnCount = 0;
+            }
+
+            void DoAction(int32 const action)
+            {
+                if (action == ACTION_METEOR_STRIKE_BURN)
+                {
+                    DoCast(me, SPELL_METEOR_STRIKE_FIRE_AURA_2, true);
+                    me->setActive(true);
+                    _events.ScheduleEvent(EVENT_SPAWN_METEOR_FLAME, 500);
+                }
+            }
+
+            void IsSummonedBy(Unit* /*summoner*/)
+            {
+                // Let Halion Controller count as summoner.
+                if (Creature* controller = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_HALION_CONTROLLER)))
+                    controller->AI()->JustSummoned(me);
+            }
+
+            void UpdateAI(uint32 const diff)
+            {
+                if (_spawnCount > 5)
+                    return;
+
+                _events.Update(diff);
+
+                if (_events.ExecuteEvent() == EVENT_SPAWN_METEOR_FLAME)
+                {
+                    Position pos;
+                    me->GetNearPosition(pos, _range, 0.0f);
+
+                    if (Creature* flame = me->SummonCreature(NPC_METEOR_STRIKE_FLAME, pos, TEMPSUMMON_TIMED_DESPAWN, 25000))
+                    {
+                        if (Creature* controller = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_HALION_CONTROLLER)))
+                            controller->AI()->JustSummoned(flame);
+
+                        flame->CastSpell(flame, SPELL_METEOR_STRIKE_FIRE_AURA_2, true);
+                        ++_spawnCount;
+                    }
+                    _range += 5.0f;
+                    _events.ScheduleEvent(EVENT_SPAWN_METEOR_FLAME, 800);
+                }
+            }
+
+        private:
+            InstanceScript* _instance;
+            EventMap _events;
+            float _range;
+            uint8 _spawnCount;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return GetRubySanctumAI<npc_meteor_strikeAI>(creature);
+        }
+};
+
+class npc_combustion_consumption : public CreatureScript
+{
+    public:
+        npc_combustion_consumption() : CreatureScript("npc_combustion_consumption") { }
+
+        struct npc_combustion_consumptionAI : public Scripted_NoMovementAI
+        {
+            npc_combustion_consumptionAI(Creature* creature) : Scripted_NoMovementAI(creature),
+                   _summonerGuid(0), _instance(creature->GetInstanceScript())
+            {
+                switch (me->GetEntry())
+                {
+                    case NPC_COMBUSTION:
+                        _explosionSpell = SPELL_FIERY_COMBUSTION_EXPLOSION;
+                        _damageSpell = SPELL_COMBUSTION_DAMAGE_AURA;
+                        break;
+                    case NPC_CONSUMPTION:
+                        _explosionSpell = SPELL_SOUL_CONSUMPTION_EXPLOSION;
+                        _damageSpell = SPELL_CONSUMPTION_DAMAGE_AURA;
+                        me->SetPhaseMask(0x20, true);
+                        break;
+                    default: // Should never happen
+                        _explosionSpell = 0;
+                        _damageSpell = 0;
+                        break;
+                }
+                if (IsHeroic())
+                    me->SetPhaseMask(0x01 | 0x20, true);
+            }
+
+            void IsSummonedBy(Unit* summoner)
+            {
+                // Let Halion Controller count as summoner
+                if (Creature* controller = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_HALION_CONTROLLER)))
+                    controller->AI()->JustSummoned(me);
+
+                _summonerGuid = summoner->GetGUID();
+            }
+
+            void SetData(uint32 type, uint32 value)
+            {
+                Unit* summoner = ObjectAccessor::GetUnit(*me, _summonerGuid);
+
+                if (type != DATA_STACKS_DISPELLED || !_damageSpell || !_explosionSpell || !summoner)
+                    return;
+
+                me->CastCustomSpell(SPELL_SCALE_AURA, SPELLVALUE_AURA_STACK, value, me);
+                DoCast(me, _damageSpell);
+
+                int32 damage = 1200 + (value * 1290); // Needs moar research.
+                // Target is TARGET_UNIT_AREA_ALLY_SRC (TARGET_SRC_CASTER)
+                summoner->CastCustomSpell(_explosionSpell, SPELLVALUE_BASE_POINT0, damage, summoner);
+            }
+
+            void UpdateAI(uint32 const /*diff*/) { }
+
+        private:
+            InstanceScript* _instance;
+            uint32 _explosionSpell;
+            uint32 _damageSpell;
+            uint64 _summonerGuid;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return GetRubySanctumAI<npc_combustion_consumptionAI>(creature);
+        }
+};
+
+class npc_orb_carrier : public CreatureScript
+{
+    public:
+        npc_orb_carrier() : CreatureScript("npc_orb_carrier") { }
+
+        struct npc_orb_carrierAI : public ScriptedAI
+        {
+            npc_orb_carrierAI(Creature* creature) : ScriptedAI(creature)
+            {
+                ASSERT(creature->GetVehicleKit());
+                me->setActive(true);
+                _shoot = false;
+            }
+
+            void UpdateAI(uint32 const diff)
+            {
+                if (_shoot)
+                {
+                    _events.RescheduleEvent(EVENT_TRACK_ROTATION, 10000);
+                    _shoot = false;
+                    return;
+                }
+
+                _events.Update(diff);
+                if (_events.ExecuteEvent() == EVENT_TRACK_ROTATION)
+                {
+                    me->CastSpell((Unit*)NULL, SPELL_TRACK_ROTATION, false);
+                    _events.ScheduleEvent(EVENT_TRACK_ROTATION, 500);
+                }
+            }
+
+            void DoAction(int32 const action)
+            {
+                switch (action)
+                {
+                    case ACTION_SHOOT:
+                    {
+                        _shoot = true;
+                        float x, y;
+                        Vehicle* vehicle = me->GetVehicleKit();
+                        Unit* southOrb = vehicle->GetPassenger(SEAT_SOUTH);
+                        Unit* northOrb = vehicle->GetPassenger(SEAT_NORTH);
+
+                        // for some reason, passenger location always in same position with vehicle location
+                        // workaround, summon another orb to do spell damage
+                        if (southOrb && northOrb)
+                        {
+                            if (northOrb->GetTypeId() != TYPEID_UNIT || southOrb->GetTypeId() != TYPEID_UNIT)
+                                return;
+
+                            me->GetNearPoint2D(x, y, RING_RADIUS, me->GetOrientation() + M_PI/2);
+                            Creature* orb1 = me->SummonCreature(NPC_SHADOW_ORB_N,x,y,me->GetPositionZ(),0,TEMPSUMMON_TIMED_DESPAWN,9000);
+                            me->GetNearPoint2D(x, y, RING_RADIUS, me->GetOrientation() + M_PI*1.5);
+                            Creature* orb2 = me->SummonCreature(NPC_SHADOW_ORB_S,x,y,me->GetPositionZ(),0,TEMPSUMMON_TIMED_DESPAWN,9000);
+                            if (orb1 && orb2)
+                            {
+                                // set in combat and passive, because it will stop spell if deals damage in middle of channeling
+                                orb1->SetReactState(REACT_PASSIVE);
+                                orb2->SetReactState(REACT_PASSIVE);
+                                orb1->AI()->DoZoneInCombat();
+                                orb2->AI()->DoZoneInCombat();
+                                orb1->AI()->Talk(EMOTE_WARN_LASER);
+                                orb1->CastSpell(orb1, SPELL_TWILIGHT_PULSE_PERIODIC, true);
+                                orb2->CastSpell(orb2, SPELL_TWILIGHT_PULSE_PERIODIC, true);
+                                orb1->CastSpell(orb2, SPELL_TWILIGHT_CUTTER, false);
+                            }
+                        }
+
+                        if (!IsHeroic())
+                            return;
+
+                        Unit* eastOrb = vehicle->GetPassenger(SEAT_EAST);
+                        Unit* westOrb = vehicle->GetPassenger(SEAT_WEST);
+                        if (eastOrb && westOrb)
+                        {
+                            if (eastOrb->GetTypeId() != TYPEID_UNIT || westOrb->GetTypeId() != TYPEID_UNIT)
+                                return;
+
+                            me->GetNearPoint2D(x, y, RING_RADIUS, me->GetOrientation() + M_PI);
+                            Creature* orb3 = me->SummonCreature(NPC_SHADOW_ORB_E,x,y,me->GetPositionZ(),0,TEMPSUMMON_TIMED_DESPAWN,9000);
+                            me->GetNearPoint2D(x, y, RING_RADIUS, me->GetOrientation());
+                            Creature* orb4 = me->SummonCreature(NPC_SHADOW_ORB_W,x,y,me->GetPositionZ(),0,TEMPSUMMON_TIMED_DESPAWN,9000);
+                            if (orb3 && orb4)
+                            {
+                                orb3->SetReactState(REACT_PASSIVE);
+                                orb4->SetReactState(REACT_PASSIVE);
+                                orb3->AI()->DoZoneInCombat();
+                                orb4->AI()->DoZoneInCombat();
+                                orb3->ToCreature()->AI()->Talk(EMOTE_WARN_LASER);
+                                orb3->CastSpell(orb3, SPELL_TWILIGHT_PULSE_PERIODIC, true);
+                                orb4->CastSpell(orb4, SPELL_TWILIGHT_PULSE_PERIODIC, true);
+                                orb3->CastSpell(orb4, SPELL_TWILIGHT_CUTTER, false);
+                            }
+                        }
+                        break;
+                    }
+                    case ACTION_ROTATE:
+                        _events.ScheduleEvent(EVENT_TRACK_ROTATION, 2000);
+                        break;
+                    case ACTION_STOP_ROTATE:
+                        _events.CancelEvent(EVENT_TRACK_ROTATION);
+                        break;
+                    default:
+                        break;
+                }
+            }
+
+        private:
+            bool _shoot;
+            EventMap _events;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return GetRubySanctumAI<npc_orb_carrierAI>(creature);
+        }
+};
+
+class npc_combat_stalker : public CreatureScript
+{
+    public:
+        npc_combat_stalker() : CreatureScript("npc_combat_stalker") { }
+
+        struct npc_combat_stalkerAI : public Scripted_NoMovementAI
+        {
+            npc_combat_stalkerAI(Creature* creature) : Scripted_NoMovementAI(creature),
+                   _instance(creature->GetInstanceScript())
+            {
+                creature->SetPhaseMask(0x20|0x1, true);
+                me->setActive(true);
+            }
+
+            void Reset()
+            {
+                ScriptedAI::Reset();
+            }
+
+            void EnterCombat(Unit* who)
+            {
+                DoZoneInCombat();
+                if (who->GetTypeId() == TYPEID_UNIT)
+                    if (who->ToCreature()->GetEntry() == NPC_HALION || who->ToCreature()->GetEntry() == NPC_TWILIGHT_HALION)
+                        me->AddThreat(who, float(urand(1,3) * 100.0f));
+
+                _wipeCheck = true;
+            }
+
+            void EnterEvadeMode()
+            {
+                if (Creature* halion = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_HALION)))
+                    halion->AI()->EnterEvadeMode();
+
+                if (Creature* twilightHalion = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_TWILIGHT_HALION)))
+                    twilightHalion->AI()->EnterEvadeMode();
+
+                _wipeCheck = false;
+
+                ScriptedAI::EnterEvadeMode();
+            }
+
+            void UpdateAI(uint32 const diff)
+            {
+                if (!me->isInCombat())
+                    return;
+
+                std::list<HostileReference*> const& threatList = me->getThreatManager().getThreatList();
+                if (threatList.empty())
+                {
+                    EnterEvadeMode();
+                    return;
+                }
+
+                if (!_wipeCheck)
+                    return;
+
+                _wipeCheck = !_wipeCheck;
+                for (std::list<HostileReference*>::const_iterator itr = threatList.begin(); itr != threatList.end(); ++itr)
+                    if (Unit* refTarget = (*itr)->getTarget())
+                        if (refTarget->GetTypeId() == TYPEID_PLAYER)
+                            return;
+
+                EnterEvadeMode();
+            }
+
+        private:
+            InstanceScript* _instance;
+            bool _wipeCheck;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return GetRubySanctumAI<npc_combat_stalkerAI>(creature);
+        }
+};
+
+class npc_living_inferno : public CreatureScript
+{
+    public:
+        npc_living_inferno() : CreatureScript("npc_living_inferno") { }
+
+        struct npc_living_infernoAI : public ScriptedAI
+        {
+            npc_living_infernoAI(Creature* creature) : ScriptedAI(creature) { }
+
+            void JustSummoned(Creature* /*summoner*/)
+            {
+                me->SetInCombatWithZone();
+                DoCast(me, SPELL_BLAZING_AURA);
+            }
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return GetRubySanctumAI<npc_living_infernoAI>(creature);
+        }
+};
+
+//! Need sniff data
+class npc_living_ember : public CreatureScript
+{
+    public:
+        npc_living_ember() : CreatureScript("npc_living_ember") { }
+
+        struct npc_living_emberAI : public ScriptedAI
+        {
+            npc_living_emberAI(Creature* creature) : ScriptedAI(creature) { }
+
+            void Reset()
+            {
+                _hasEnraged = false;
+            }
+
+            void EnterCombat(Unit* /*who*/)
+            {
+                _events.Reset();
+                _events.ScheduleEvent(EVENT_EMBER_ENRAGE, 20000);
+            }
+
+            void UpdateAI(uint32 const diff)
+            {
+                if (!UpdateVictim())
+                    return;
+
+                _events.Update(diff);
+
+                if (!me->HasUnitState(UNIT_STATE_CASTING))
+                    return;
+
+                if (!_hasEnraged && _events.ExecuteEvent() == EVENT_EMBER_ENRAGE)
+                {
+                    _hasEnraged = true;
+                    DoCast(me, SPELL_BERSERK);
+                }
+
+                DoMeleeAttackIfReady();
+            }
+
+        private:
+            EventMap _events;
+            bool _hasEnraged;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return GetRubySanctumAI<npc_living_emberAI>(creature);
+        }
+};
+
+class spell_halion_meteor_strike_marker : public SpellScriptLoader
+{
+    public:
+        spell_halion_meteor_strike_marker() : SpellScriptLoader("spell_halion_meteor_strike_marker") { }
+
+        class spell_halion_meteor_strike_marker_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_halion_meteor_strike_marker_AuraScript);
+
+            void OnRemove(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
+            {
+                if (!GetCaster())
+                    return;
+
+                if (GetTargetApplication()->GetRemoveMode() == AURA_REMOVE_BY_EXPIRE)
+                    if (Creature* creCaster = GetCaster()->ToCreature())
+                        creCaster->AI()->DoAction(ACTION_METEOR_STRIKE_AOE);
+            }
+
+            void Register()
+            {
+                AfterEffectRemove += AuraEffectRemoveFn(spell_halion_meteor_strike_marker_AuraScript::OnRemove, EFFECT_0, SPELL_AURA_DUMMY, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_halion_meteor_strike_marker_AuraScript();
+        }
+};
+
+class spell_halion_fiery_combustion : public SpellScriptLoader
+{
+    public:
+        spell_halion_fiery_combustion() : SpellScriptLoader("spell_halion_fiery_combustion") { }
+
+        class spell_halion_fiery_combustion_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_halion_fiery_combustion_AuraScript);
+
+            bool Validate(SpellEntry const* /*spell*/)
+            {
+                if (!sSpellMgr->GetSpellInfo(SPELL_MARK_OF_COMBUSTION))
+                    return false;
+                return true;
+            }
+
+            void OnRemove(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
+            {
+                if (GetTarget()->HasAura(SPELL_MARK_OF_COMBUSTION))
+                    GetTarget()->RemoveAurasDueToSpell(SPELL_MARK_OF_COMBUSTION, 0, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+
+            void OnApply(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
+            {
+                GetTarget()->CastSpell(GetTarget(), SPELL_MARK_OF_COMBUSTION, true);
+            }
+
+            void AddMarkStack(AuraEffect const* /*aurEff*/)
+            {
+                GetTarget()->CastSpell(GetTarget(), SPELL_MARK_OF_COMBUSTION, true);
+            }
+
+            void Register()
+            {
+                OnEffectPeriodic += AuraEffectPeriodicFn(spell_halion_fiery_combustion_AuraScript::AddMarkStack, EFFECT_0, SPELL_AURA_PERIODIC_DAMAGE);
+                AfterEffectApply += AuraEffectApplyFn(spell_halion_fiery_combustion_AuraScript::OnApply, EFFECT_0, SPELL_AURA_PERIODIC_DAMAGE, AURA_EFFECT_HANDLE_REAL);
+                AfterEffectRemove += AuraEffectRemoveFn(spell_halion_fiery_combustion_AuraScript::OnRemove, EFFECT_0, SPELL_AURA_PERIODIC_DAMAGE, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_halion_fiery_combustion_AuraScript();
+        }
+};
+
+class spell_halion_soul_consumption : public SpellScriptLoader
+{
+    public:
+        spell_halion_soul_consumption() : SpellScriptLoader("spell_halion_soul_consumption") { }
+
+        class spell_halion_soul_consumption_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_halion_soul_consumption_AuraScript);
+
+            bool Validate(SpellEntry const* /*spell*/)
+            {
+                if (!sSpellMgr->GetSpellInfo(SPELL_MARK_OF_CONSUMPTION))
+                    return false;
+                return true;
+            }
+
+            void OnRemove(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
+            {
+                if (GetTarget()->HasAura(SPELL_MARK_OF_CONSUMPTION))
+                    GetTarget()->RemoveAurasDueToSpell(SPELL_MARK_OF_CONSUMPTION, 0, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+
+            void OnApply(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
+            {
+                GetTarget()->CastSpell(GetTarget(), SPELL_MARK_OF_CONSUMPTION, true);
+            }
+
+            void AddMarkStack(AuraEffect const* /*aurEff*/)
+            {
+                GetTarget()->CastSpell(GetTarget(), SPELL_MARK_OF_CONSUMPTION, true);
+            }
+
+            void Register()
+            {
+                OnEffectPeriodic += AuraEffectPeriodicFn(spell_halion_soul_consumption_AuraScript::AddMarkStack, EFFECT_0, SPELL_AURA_PERIODIC_DAMAGE);
+                AfterEffectApply += AuraEffectApplyFn(spell_halion_soul_consumption_AuraScript::OnApply, EFFECT_0, SPELL_AURA_PERIODIC_DAMAGE, AURA_EFFECT_HANDLE_REAL);
+                AfterEffectRemove += AuraEffectRemoveFn(spell_halion_soul_consumption_AuraScript::OnRemove, EFFECT_0, SPELL_AURA_PERIODIC_DAMAGE, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_halion_soul_consumption_AuraScript();
+        }
+};
+
+class spell_halion_mark_of_combustion : public SpellScriptLoader
+{
+    public:
+        spell_halion_mark_of_combustion() : SpellScriptLoader("spell_halion_mark_of_combustion") { }
+
+        class spell_halion_mark_of_combustion_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_halion_mark_of_combustion_AuraScript);
+
+            bool Validate(SpellEntry const* /*spell*/)
+            {
+                if (!sSpellMgr->GetSpellInfo(SPELL_FIERY_COMBUSTION_SUMMON))
+                    return false;
+                if (!sSpellMgr->GetSpellInfo(SPELL_FIERY_COMBUSTION_EXPLOSION))
+                    return false;
+                return true;
+            }
+
+            void OnRemove(AuraEffect const* aurEff, AuraEffectHandleModes /*mode*/)
+            {
+                Unit* target = GetTarget();
+
+                if (GetTargetApplication()->GetRemoveMode() == AURA_REMOVE_BY_ENEMY_SPELL) // Purged
+                    target->RemoveAurasDueToSpell(SPELL_FIERY_COMBUSTION, 0, 0, AURA_REMOVE_BY_ENEMY_SPELL);
+
+                //! Don't process if the aura is not considered expired.
+                //! The hook will still be called upon dispelling Soul Consumption because
+                //! it causes Mark of Combustion to be considered removed by expire.
+                //! It will also be called upon purging the mark, but purging it will
+                //! trigger Fiery Conbustion's dispel.
+                //! Note: This is really fubarish, we need something simpler.
+                if (GetTargetApplication()->GetRemoveMode() != AURA_REMOVE_BY_EXPIRE)
+                    return;
+
+                InstanceScript* instance = target->GetInstanceScript();
+                if (!instance)
+                    return;
+
+                uint8 stacks = aurEff->GetBase()->GetStackAmount();
+
+                // Keep track of stacks when dispelling, there's only one effect in the spell.
+                CustomSpellValues values;
+                values.AddSpellMod(SPELLVALUE_BASE_POINT1, stacks);
+
+                target->CastCustomSpell(SPELL_FIERY_COMBUSTION_SUMMON, values, target, true, NULL, NULL, GetCasterGUID());
+            }
+
+            void Register()
+            {
+                AfterEffectRemove += AuraEffectRemoveFn(spell_halion_mark_of_combustion_AuraScript::OnRemove, EFFECT_0, SPELL_AURA_DUMMY, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_halion_mark_of_combustion_AuraScript();
+        }
+};
+
+class spell_halion_mark_of_consumption : public SpellScriptLoader
+{
+    public:
+        spell_halion_mark_of_consumption() : SpellScriptLoader("spell_halion_mark_of_consumption") { }
+
+        class spell_halion_mark_of_consumption_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_halion_mark_of_consumption_AuraScript);
+
+            bool Validate(SpellInfo const* /*spell*/)
+            {
+                if (!sSpellMgr->GetSpellInfo(SPELL_SOUL_CONSUMPTION_SUMMON))
+                    return false;
+                if (!sSpellMgr->GetSpellInfo(SPELL_SOUL_CONSUMPTION_EXPLOSION))
+                    return false;
+                return true;
+            }
+
+            void OnRemove(AuraEffect const* aurEff, AuraEffectHandleModes /*mode*/)
+            {
+                Unit* target = GetTarget();
+
+                if (GetTargetApplication()->GetRemoveMode() == AURA_REMOVE_BY_ENEMY_SPELL) // Purged
+                    target->RemoveAurasDueToSpell(SPELL_SOUL_CONSUMPTION, 0, 0, AURA_REMOVE_BY_ENEMY_SPELL);
+
+                //! Don't process if the aura is not considered expired.
+                //! The hook will still be called upon dispelling Soul Consumption because
+                //! it causes Mark of Consumption to be considered removed by expire.
+                //! It will also be called upon purging the mark, but purging it will
+                //! trigger Soul Consumption's dispel.
+                //! Note: This is really fubarish, we need something simpler.
+                if (GetTargetApplication()->GetRemoveMode() != AURA_REMOVE_BY_EXPIRE)
+                    return;
+
+                InstanceScript* instance = target->GetInstanceScript();
+                if (!instance)
+                    return;
+
+                uint8 stacks = aurEff->GetBase()->GetStackAmount();
+
+                // Keep track of stacks when dispelling, there's only one effect in the spell.
+                CustomSpellValues values;
+                values.AddSpellMod(SPELLVALUE_BASE_POINT1, stacks);
+
+                target->CastCustomSpell(SPELL_SOUL_CONSUMPTION_SUMMON, values, target, true, NULL, NULL, GetCasterGUID());
+            }
+
+            void Register()
+            {
+                AfterEffectRemove += AuraEffectRemoveFn(spell_halion_mark_of_consumption_AuraScript::OnRemove, EFFECT_0, SPELL_AURA_DUMMY, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_halion_mark_of_consumption_AuraScript();
+        }
+};
+
+class spell_halion_combustion_consumption_summon : public SpellScriptLoader
+{
+    public:
+        spell_halion_combustion_consumption_summon() : SpellScriptLoader("spell_halion_combustion_consumption_summon") { }
+
+        class spell_halion_combustion_consumption_summon_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_halion_combustion_consumption_summon_SpellScript);
+
+            void HandleSummon(SpellEffIndex effIndex)
+            {
+                PreventHitDefaultEffect(effIndex);
+                Unit* caster = GetCaster();
+                uint32 entry = uint32(GetSpellInfo()->Effects[effIndex].MiscValue);
+                SummonPropertiesEntry const* properties = sSummonPropertiesStore.LookupEntry(uint32(GetSpellInfo()->Effects[effIndex].MiscValueB));
+                uint32 duration = uint32(GetSpellInfo()->GetDuration());
+
+                InstanceScript* instance = caster->GetInstanceScript();
+                if (!instance)
+                    return;
+
+                Position pos;
+                caster->GetPosition(&pos);
+                if (Creature* summon = caster->GetMap()->SummonCreature(entry, pos, properties, duration, caster, GetSpellInfo()->Id))
+                    if (summon->IsAIEnabled)
+                        summon->AI()->SetData(DATA_STACKS_DISPELLED, GetSpellValue()->EffectBasePoints[EFFECT_1]);
+            }
+
+            void Register()
+            {
+                OnEffectHit += SpellEffectFn(spell_halion_combustion_consumption_summon_SpellScript::HandleSummon, EFFECT_0, SPELL_EFFECT_SUMMON);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_halion_combustion_consumption_summon_SpellScript();
+        }
+};
+
+class spell_halion_leave_twilight_realm : public SpellScriptLoader
+{
+    public:
+        spell_halion_leave_twilight_realm() : SpellScriptLoader("spell_halion_leave_twilight_realm") { }
+
+        class spell_halion_leave_twilight_realm_AuraScript: public AuraScript
+        {
+            PrepareAuraScript(spell_halion_leave_twilight_realm_AuraScript);
+
+            void OnRemove(AuraEffect const* aurEff, AuraEffectHandleModes /*handle*/)
+            {
+                GetTarget()->RemoveAurasDueToSpell(SPELL_TWILIGHT_REALM);
+            }
+
+            void Register()
+            {
+                AfterEffectRemove += AuraEffectRemoveFn(spell_halion_leave_twilight_realm_AuraScript::OnRemove, EFFECT_0, SPELL_AURA_DUMMY, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        class spell_halion_leave_twilight_realm_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_halion_leave_twilight_realm_SpellScript);
+
+            void HandleBeforeHit()
+            {
+                if (Player* player = GetHitPlayer())
+                    player->RemoveAurasDueToSpell(SPELL_SOUL_CONSUMPTION, 0, 0, AURA_REMOVE_BY_ENEMY_SPELL);
+            }
+
+            void FilterTargets(std::list<Unit*>& unitList)
+            {
+                if (!unitList.empty())
+                    unitList.remove_if(Trinity::UnitAuraCheck(false, SPELL_TWILIGHT_REALM));
+            }
+
+            void Register()
+            {
+                BeforeHit += SpellHitFn(spell_halion_leave_twilight_realm_SpellScript::HandleBeforeHit);
+                OnUnitTargetSelect += SpellUnitTargetFn(spell_halion_leave_twilight_realm_SpellScript::FilterTargets, EFFECT_0, TARGET_UNIT_TARGET_ANY);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_halion_leave_twilight_realm_SpellScript();
+        }
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_halion_leave_twilight_realm_AuraScript();
+        }
+};
+
+class spell_halion_enter_twilight_realm : public SpellScriptLoader
+{
+    public:
+        spell_halion_enter_twilight_realm() : SpellScriptLoader("spell_halion_enter_twilight_realm") { }
+
+        class spell_halion_enter_twilight_realm_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_halion_enter_twilight_realm_SpellScript);
+
+            void HandleBeforeHit()
+            {
+                if (Player* player = GetHitPlayer())
+                    player->RemoveAurasDueToSpell(SPELL_FIERY_COMBUSTION, 0, 0, AURA_REMOVE_BY_ENEMY_SPELL);
+            }
+
+            void Register()
+            {
+                BeforeHit += SpellHitFn(spell_halion_enter_twilight_realm_SpellScript::HandleBeforeHit);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_halion_enter_twilight_realm_SpellScript();
+        }
+};
+
+class spell_halion_twilight_phasing : public SpellScriptLoader
+{
+    public:
+        spell_halion_twilight_phasing() : SpellScriptLoader("spell_halion_twilight_phasing") { }
+
+        class spell_halion_twilight_phasing_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_halion_twilight_phasing_SpellScript);
+
+            void Phase()
+            {
+                Unit* caster = GetCaster();
+                caster->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                caster->CastSpell(HalionSpawnPos.GetPositionX(), HalionSpawnPos.GetPositionY(), HalionSpawnPos.GetPositionZ(), SPELL_SUMMON_TWILIGHT_PORTAL, true);
+            }
+
+            void Register()
+            {
+                OnHit += SpellHitFn(spell_halion_twilight_phasing_SpellScript::Phase);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_halion_twilight_phasing_SpellScript();
+        }
+};
+
+class spell_halion_clear_debuffs : public SpellScriptLoader
+{
+    public:
+        spell_halion_clear_debuffs() : SpellScriptLoader("spell_halion_clear_debuffs") { }
+
+        class spell_halion_clear_debuffs_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_halion_clear_debuffs_SpellScript);
+
+            bool Validate(SpellInfo const* /*spell*/)
+            {
+                if (!sSpellMgr->GetSpellInfo(SPELL_CLEAR_DEBUFFS))
+                    return false;
+                if (!sSpellMgr->GetSpellInfo(SPELL_TWILIGHT_REALM))
+                    return false;
+                return true;
+            }
+
+            void HandleScript(SpellEffIndex effIndex)
+            {
+                if (GetHitUnit()->HasAura(GetSpellInfo()->Effects[effIndex].CalcValue()))
+                    GetHitUnit()->RemoveAurasDueToSpell(GetSpellInfo()->Effects[effIndex].CalcValue());
+            }
+
+            void Register()
+            {
+                OnEffectHitTarget += SpellEffectFn(spell_halion_clear_debuffs_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_halion_clear_debuffs_SpellScript();
+        }
+};
+
+class TwilightCutterSelector
+{
+    public:
+        TwilightCutterSelector(Unit* caster, Unit* cutterCaster) : _caster(caster), _cutterCaster(cutterCaster) {}
+
+        bool operator()(Unit* unit)
+        {
+            return !unit->IsInBetween(_caster, _cutterCaster, 4.0f);
+        }
+
+    private:
+        Unit* _caster;
+        Unit* _cutterCaster;
+};
+
+class spell_halion_twilight_cutter : public SpellScriptLoader
+{
+    public:
+        spell_halion_twilight_cutter() : SpellScriptLoader("spell_halion_twilight_cutter") { }
+
+        class spell_halion_twilight_cutter_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_halion_twilight_cutter_SpellScript);
+
+            void RemoveNotBetween(std::list<Unit*>& unitList)
+            {
+                if (unitList.empty())
+                    return;
+
+                Unit* caster = GetCaster();
+                if (Aura* cutter = caster->GetAura(SPELL_TWILIGHT_CUTTER))
+                {
+                    if (Unit* cutterCaster = cutter->GetCaster())
+                    {
+                        unitList.remove_if(TwilightCutterSelector(caster, cutterCaster));
+                        return;
+                    }
+                }
+
+                // In case cutter caster werent found for some reason
+                unitList.clear();
+            }
+
+            void Register()
+            {
+                OnUnitTargetSelect += SpellUnitTargetFn(spell_halion_twilight_cutter_SpellScript::RemoveNotBetween, EFFECT_0, TARGET_UNIT_SRC_AREA_ENEMY);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_halion_twilight_cutter_SpellScript();
+        }
+};
+
+class spell_halion_track_rotation : public SpellScriptLoader
+{
+    public:
+        spell_halion_track_rotation() : SpellScriptLoader("spell_halion_track_rotation") { }
+
+        class spell_halion_track_rotation_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_halion_track_rotation_AuraScript);
+
+            void HandleEffectApply(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
+            {
+                Unit* caster = GetCaster();
+                if (Unit* target = GetTarget())
+                {
+                    caster->SetOrientation(caster->GetAngle(target));
+                    caster->SendMovementFlagUpdate();
+                }
+            }
+
+            void Register()
+            {
+                OnEffectApply += AuraEffectApplyFn(spell_halion_track_rotation_AuraScript::HandleEffectApply, EFFECT_0, SPELL_AURA_DUMMY, AURA_EFFECT_HANDLE_REAL_OR_REAPPLY_MASK);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_halion_track_rotation_AuraScript();
+        }
+};
+
+
+class go_exit_twilight_realm : public GameObjectScript
+{
+    public:
+    go_exit_twilight_realm() : GameObjectScript("go_exit_twilight_realm") { }
+
+    bool OnGossipHello(Player* player, GameObject* /*go*/)
+    {
+        player->CastSpell(player,SPELL_LEAVE_TWILIGHT_REALM,true);
+        return true;
+    }
+};
+
+void AddSC_boss_halion()
+{
+    new boss_halion();
+    new boss_twilight_halion();
+    new npc_halion_controller();
+    new npc_meteor_strike_initial();
+    new npc_meteor_strike();
+    new npc_combustion_consumption();
+    new npc_orb_carrier();
+    new npc_living_inferno();
+    new npc_living_ember();
+    new spell_halion_meteor_strike_marker();
+    new spell_halion_combustion_consumption_summon();
+    new spell_halion_mark_of_combustion();
+    new spell_halion_mark_of_consumption();
+    new spell_halion_fiery_combustion();
+    new spell_halion_soul_consumption();
+    new spell_halion_leave_twilight_realm();
+    new spell_halion_enter_twilight_realm();
+    new spell_halion_twilight_phasing();
+    new spell_halion_twilight_cutter();
+    new spell_halion_clear_debuffs();
+    new go_exit_twilight_realm();
+    new spell_halion_track_rotation();
+}
diff --git a/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/instance_ruby_sanctum.cpp b/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/instance_ruby_sanctum.cpp
index f9e302d..4011b30 100644
--- a/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/instance_ruby_sanctum.cpp
+++ b/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/instance_ruby_sanctum.cpp
@@ -36,18 +36,23 @@ class instance_ruby_sanctum : public InstanceMapScript
             {
                 SetBossNumber(EncounterCount);
                 LoadDoorData(doorData);
-                BaltharusTheWarbornGUID = 0;
-                GeneralZarithrianGUID   = 0;
-                SavianaRagefireGUID     = 0;
-                HalionGUID              = 0;
-                HalionControllerGUID    = 0;
+                BaltharusTheWarbornGUID  = 0;
+                GeneralZarithrianGUID    = 0;
+                SavianaRagefireGUID      = 0;
+                HalionGUID               = 0;
+                TwilightHalionGUID       = 0;
+                OrbCarrierGUID           = 0;
+                OrbRotationFocusGUID     = 0;
+                HalionControllerGUID     = 0;
+                CombatStalkerGUID        = 0;
                 CrystalChannelTargetGUID = 0;
-                XerestraszaGUID         = 0;
-                BaltharusSharedHealth   = 0;
-                FlameWallsGUID          = 0;
-                FlameRingGUID           = 0;
-                memset(ZarithianSpawnStalkerGUID, 0, 2*sizeof(uint64));
-                memset(BurningTreeGUID, 0, 4*sizeof(uint64));
+                XerestraszaGUID          = 0;
+                BaltharusSharedHealth    = 0;
+                FlameWallsGUID           = 0;
+                FlameRingGUID            = 0;
+
+                memset(ZarithrianSpawnStalkerGUID, 0, 2 * sizeof(uint64));
+                memset(BurningTreeGUID, 0, 4 * sizeof(uint64));
             }
 
             void OnCreatureCreate(Creature* creature)
@@ -66,19 +71,32 @@ class instance_ruby_sanctum : public InstanceMapScript
                     case NPC_HALION:
                         HalionGUID = creature->GetGUID();
                         break;
+                    case NPC_TWILIGHT_HALION:
+                        TwilightHalionGUID = creature->GetGUID();
+                        break;
                     case NPC_HALION_CONTROLLER:
                         HalionControllerGUID = creature->GetGUID();
+                        break;
+                    case NPC_ORB_CARRIER:
+                        OrbCarrierGUID = creature->GetGUID();
+                        break;
+                    case NPC_ORB_ROTATION_FOCUS:
+                        OrbRotationFocusGUID = creature->GetGUID();
+                        break;
+                    case NPC_COMBAT_STALKER:
+                        CombatStalkerGUID = creature->GetGUID();
+                        break;
                     case NPC_BALTHARUS_TARGET:
                         CrystalChannelTargetGUID = creature->GetGUID();
                         break;
                     case NPC_XERESTRASZA:
                         XerestraszaGUID = creature->GetGUID();
                         break;
-                    case NPC_ZARITHIAN_SPAWN_STALKER:
-                        if (!ZarithianSpawnStalkerGUID[0])
-                            ZarithianSpawnStalkerGUID[0] = creature->GetGUID();
+                    case NPC_ZARITHRIAN_SPAWN_STALKER:
+                        if (!ZarithrianSpawnStalkerGUID[0])
+                            ZarithrianSpawnStalkerGUID[0] = creature->GetGUID();
                         else
-                            ZarithianSpawnStalkerGUID[1] = creature->GetGUID();
+                            ZarithrianSpawnStalkerGUID[1] = creature->GetGUID();
                         break;
                     default:
                         break;
@@ -100,6 +118,9 @@ class instance_ruby_sanctum : public InstanceMapScript
                     case GO_FLAME_RING:
                         FlameRingGUID = go->GetGUID();
                         break;
+                    case GO_TWILIGHT_FLAME_RING:
+                        TwilightFlameRingGUID = go->GetGUID();
+                        break;
                     case GO_BURNING_TREE_1:
                         BurningTreeGUID[0] = go->GetGUID();
                         if (GetBossState(DATA_GENERAL_ZARITHRIAN) == DONE)
@@ -151,24 +172,30 @@ class instance_ruby_sanctum : public InstanceMapScript
                         return SavianaRagefireGUID;
                     case DATA_GENERAL_ZARITHRIAN:
                         return GeneralZarithrianGUID;
-                    case DATA_ZARITHIAN_SPAWN_STALKER_1:
-                        return ZarithianSpawnStalkerGUID[0];
-                    case DATA_ZARITHIAN_SPAWN_STALKER_2:
-                        return ZarithianSpawnStalkerGUID[1];
+                    case DATA_ZARITHRIAN_SPAWN_STALKER_1:
+                    case DATA_ZARITHRIAN_SPAWN_STALKER_2:
+                        return ZarithrianSpawnStalkerGUID[type - DATA_ZARITHRIAN_SPAWN_STALKER_1];
                     case DATA_HALION:
                         return HalionGUID;
+                    case DATA_TWILIGHT_HALION:
+                        return TwilightHalionGUID;
+                    case DATA_ORB_CARRIER:
+                        return OrbCarrierGUID;
+                    case DATA_ORB_ROTATION_FOCUS:
+                        return OrbRotationFocusGUID;
                     case DATA_HALION_CONTROLLER:
                         return HalionControllerGUID;
                     case DATA_BURNING_TREE_1:
-                        return BurningTreeGUID[0];
                     case DATA_BURNING_TREE_2:
-                        return BurningTreeGUID[1];
                     case DATA_BURNING_TREE_3:
-                        return BurningTreeGUID[2];
                     case DATA_BURNING_TREE_4:
-                        return BurningTreeGUID[3];
+                        return BurningTreeGUID[type - DATA_BURNING_TREE_1];
                     case DATA_FLAME_RING:
                         return FlameRingGUID;
+                    case DATA_TWILIGHT_FLAME_RING:
+                        return TwilightFlameRingGUID;
+                    case DATA_COMBAT_STALKER:
+                        return CombatStalkerGUID;
                     default:
                         break;
                 }
@@ -206,18 +233,23 @@ class instance_ruby_sanctum : public InstanceMapScript
                     case DATA_GENERAL_ZARITHRIAN:
                         if (GetBossState(DATA_SAVIANA_RAGEFIRE) == DONE && GetBossState(DATA_BALTHARUS_THE_WARBORN) == DONE)
                             HandleGameObject(FlameWallsGUID, state != IN_PROGRESS);
-                        /*
                         if (state == DONE)
                             if (Creature* halionController = instance->SummonCreature(NPC_HALION_CONTROLLER, HalionControllerSpawnPos))
                                 halionController->AI()->DoAction(ACTION_INTRO_HALION);
-                        */
                         break;
                     case DATA_HALION:
-                        /*
-                        if (state != IN_PROGRESS)
-                            HandleGameObject(FlameRingGUID, true);
-                        */
+                    {
+                        if (state == IN_PROGRESS)
+                            break;
+
+                        DoUpdateWorldState(WORLDSTATE_CORPOREALITY_TOGGLE, 0);
+                        DoUpdateWorldState(WORLDSTATE_CORPOREALITY_TWILIGHT, 0);
+                        DoUpdateWorldState(WORLDSTATE_CORPOREALITY_MATERIAL, 0);
+
+                        HandleGameObject(FlameRingGUID, true);
+                        HandleGameObject(TwilightFlameRingGUID, true);
                         break;
+                    }
                     default:
                         break;
                 }
@@ -227,25 +259,18 @@ class instance_ruby_sanctum : public InstanceMapScript
 
             void SetData(uint32 type, uint32 data)
             {
-                switch (type)
-                {
-                    case DATA_BALTHARUS_SHARED_HEALTH:
-                        BaltharusSharedHealth = data;
-                        break;
-                }
+                if (type != DATA_BALTHARUS_SHARED_HEALTH)
+                    return;
+
+                BaltharusSharedHealth = data;
             }
 
             uint32 GetData(uint32 type)
             {
-                switch (type)
-                {
-                    case DATA_BALTHARUS_SHARED_HEALTH:
-                        return BaltharusSharedHealth;
-                    default:
-                        break;
-                }
+                if (type != DATA_BALTHARUS_SHARED_HEALTH)
+                    return 0;
 
-                return 0;
+                return BaltharusSharedHealth;
             }
 
             std::string GetSaveData()
@@ -259,6 +284,13 @@ class instance_ruby_sanctum : public InstanceMapScript
                 return saveStream.str();
             }
 
+            void FillInitialWorldStates(WorldPacket& data)
+            {
+                data << uint32(WORLDSTATE_CORPOREALITY_MATERIAL) << uint32(50);
+                data << uint32(WORLDSTATE_CORPOREALITY_TWILIGHT) << uint32(50);
+                data << uint32(WORLDSTATE_CORPOREALITY_TOGGLE) << uint32(0);
+            }
+
             void Load(char const* str)
             {
                 if (!str)
@@ -285,6 +317,9 @@ class instance_ruby_sanctum : public InstanceMapScript
 
                         SetBossState(i, EncounterState(tmpState));
                     }
+                    if (instance && GetBossState(DATA_GENERAL_ZARITHRIAN) == DONE && GetBossState(DATA_HALION) != DONE && HalionControllerGUID == 0)
+                        if (Creature* halionController = instance->SummonCreature(NPC_HALION_CONTROLLER, HalionControllerSpawnPos))
+                            halionController->AI()->DoAction(ACTION_INTRO_HALION);
                 }
                 else
                     OUT_LOAD_INST_DATA_FAIL;
@@ -297,13 +332,19 @@ class instance_ruby_sanctum : public InstanceMapScript
             uint64 GeneralZarithrianGUID;
             uint64 SavianaRagefireGUID;
             uint64 HalionGUID;
+            uint64 TwilightHalionGUID;
             uint64 HalionControllerGUID;
+            uint64 OrbCarrierGUID;
+            uint64 OrbRotationFocusGUID;
             uint64 CrystalChannelTargetGUID;
             uint64 XerestraszaGUID;
             uint64 FlameWallsGUID;
-            uint64 ZarithianSpawnStalkerGUID[2];
+            uint64 ZarithrianSpawnStalkerGUID[2];
             uint64 BurningTreeGUID[4];
             uint64 FlameRingGUID;
+            uint64 TwilightFlameRingGUID;
+            uint64 CombatStalkerGUID;
+
             uint32 BaltharusSharedHealth;
         };
 
diff --git a/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/ruby_sanctum.h b/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/ruby_sanctum.h
index 02ade2f..26b7c18 100644
--- a/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/ruby_sanctum.h
+++ b/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/ruby_sanctum.h
@@ -36,17 +36,22 @@ enum DataTypes
     DATA_HALION                             = 3,
 
     // Etc
-    DATA_XERESTRASZA                        = 4,
-    DATA_CRYSTAL_CHANNEL_TARGET             = 5,
-    DATA_BALTHARUS_SHARED_HEALTH            = 6,
-    DATA_ZARITHIAN_SPAWN_STALKER_1          = 7,
-    DATA_ZARITHIAN_SPAWN_STALKER_2          = 8,
-    DATA_HALION_CONTROLLER                  = 9,
-    DATA_BURNING_TREE_1                     = 10,
-    DATA_BURNING_TREE_2                     = 11,
-    DATA_BURNING_TREE_3                     = 12,
-    DATA_BURNING_TREE_4                     = 13,
-    DATA_FLAME_RING                         = 14,
+    DATA_TWILIGHT_HALION                    = 4,
+    DATA_XERESTRASZA                        = 5,
+    DATA_CRYSTAL_CHANNEL_TARGET             = 6,
+    DATA_BALTHARUS_SHARED_HEALTH            = 7,
+    DATA_ZARITHRIAN_SPAWN_STALKER_1         = 8,
+    DATA_ZARITHRIAN_SPAWN_STALKER_2         = 9,
+    DATA_HALION_CONTROLLER                  = 10,
+    DATA_ORB_CARRIER                        = 11,
+    DATA_ORB_ROTATION_FOCUS                 = 12,
+    DATA_BURNING_TREE_1                     = 13,
+    DATA_BURNING_TREE_2                     = 14,
+    DATA_BURNING_TREE_3                     = 15,
+    DATA_BURNING_TREE_4                     = 16,
+    DATA_FLAME_RING                         = 17,
+    DATA_TWILIGHT_FLAME_RING                = 18,
+    DATA_COMBAT_STALKER                     = 19,
 };
 
 enum SharedActions
@@ -66,14 +71,14 @@ enum CreaturesIds
     // General Zarithrian
     NPC_GENERAL_ZARITHRIAN                  = 39746,
     NPC_ONYX_FLAMECALLER                    = 39814,
-    NPC_ZARITHIAN_SPAWN_STALKER             = 39794,
+    NPC_ZARITHRIAN_SPAWN_STALKER            = 39794,
 
     // Saviana Ragefire
     NPC_SAVIANA_RAGEFIRE                    = 39747,
 
     // Halion
     NPC_HALION                              = 39863,
-    NPC_HALION_TWILIGHT                     = 40142,
+    NPC_TWILIGHT_HALION                     = 40142,
     NPC_HALION_CONTROLLER                   = 40146,
     NPC_LIVING_INFERNO                      = 40681,
     NPC_LIVING_EMBER                        = 40683,
@@ -81,6 +86,8 @@ enum CreaturesIds
     NPC_ORB_ROTATION_FOCUS                  = 40091,
     NPC_SHADOW_ORB_N                        = 40083,
     NPC_SHADOW_ORB_S                        = 40100,
+    NPC_SHADOW_ORB_E                        = 40468, // Not sure which entry is east and west.
+    NPC_SHADOW_ORB_W                        = 40469,
     NPC_METEOR_STRIKE_MARK                  = 40029,
     NPC_METEOR_STRIKE_NORTH                 = 40041,
     NPC_METEOR_STRIKE_EAST                  = 40042,
@@ -88,6 +95,8 @@ enum CreaturesIds
     NPC_METEOR_STRIKE_SOUTH                 = 40044,
     NPC_METEOR_STRIKE_FLAME                 = 40055,
     NPC_COMBUSTION                          = 40001,
+    NPC_CONSUMPTION                         = 40135,
+    NPC_COMBAT_STALKER                      = 40151,
 
     // Xerestrasza
     NPC_XERESTRASZA                         = 40429,
@@ -101,6 +110,7 @@ enum GameObjectsIds
     GO_FIRE_FIELD                           = 203005,
     GO_FLAME_WALLS                          = 203006,
     GO_FLAME_RING                           = 203007,
+    GO_TWILIGHT_FLAME_RING                  = 203624,
     GO_BURNING_TREE_1                       = 203034,
     GO_BURNING_TREE_2                       = 203035,
     GO_BURNING_TREE_3                       = 203036,
@@ -114,6 +124,11 @@ enum WorldStatesRS
     WORLDSTATE_CORPOREALITY_TOGGLE   = 5051,
 };
 
+enum InstanceSpell
+{
+    SPELL_BERSERK                       = 26662,
+};
+
 template<class AI>
 CreatureAI* GetRubySanctumAI(Creature* creature)
 {
-- 
1.7.8.msysgit.0

